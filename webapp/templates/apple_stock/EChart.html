<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8"/>
    <title>è·¨åº—é“ºæ›²çº¿</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js"></script>
    <style>
        :root {
            --w: 4080px;
        }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans", "Noto Sans CJK JP", Roboto, Arial;
            margin: 16px;
        }

        .wrap {
            max-width: var(--w);
            margin: 0 auto;
        }

        fieldset {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
        }

        legend {
            padding: 0 6px;
            color: #111827;
            font-weight: 600;
        }

        .row3 {
            display: grid;
            grid-template-columns: 1.2fr .9fr .9fr;
            gap: 10px;
        }

        .row4 {
            display: grid;
            grid-template-columns: .7fr .7fr .5fr .5fr;
            gap: 10px;
            max-width: 1500px;
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        label {
            font-size: 12px;
            color: #374151;
            display: block;
            margin-bottom: 6px;
        }

        input[type="text"], input[type="datetime-local"] {
            width: 80%;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #d1d5db;
            outline: none;
        }

        input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, .15);
        }

        #shops {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px 10px;
            max-height: 180px;
            overflow: auto;
        }

        #shops label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btns {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            border: 0;
            padding: 9px 12px;
            border-radius: 10px;
            cursor: pointer;
            background: #111827;
            color: #fff;
        }

        button.secondary {
            background: #374151;
        }

        button.ghost {
            background: #f3f4f6;
            color: #111827;
        }

        #chart {
            width: 100%;
            height: 540px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
        }

        .muted {
            color: #6b7280;
            font-size: 12px;
        }

        .error {
            color: #b91c1c;
            font-size: 13px;
            margin-left: 8px;
        }

        .stat {
            font-size: 12px;
            white-space: pre-wrap;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 8px;
        }

        #chart_3d_container {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .chart-3d-grid {
            display: grid;
            grid-template-columns: 1fr;  /* æ¯è¡Œä¸€ä¸ªå›¾è¡¨ */
            gap: 20px;
            margin-top: 12px;
        }

        .chart-3d-panel {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            background: #fff;
        }

        .chart-3d-title {
            font-size: 14px;
            color: #374151;
            font-weight: 600;
            margin: 0 0 12px 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-3d-swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid #d1d5db;
        }

        .chart-3d-canvas {
            width: 100%;
            height: 700px;  /* å¢åŠ é«˜åº¦ï¼Œæ¥è¿‘æ­£æ–¹å½¢ */
        }

        .chart-bubble-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .chart-bubble-panel {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            background: #fff;
        }

        .chart-bubble-title {
            font-size: 14px;
            color: #374151;
            font-weight: 600;
            margin: 0 0 12px 4px;
        }

        .chart-bubble-canvas {
            width: 100%;
            height: 600px;
        }

        #chart_stats {
            width: 100%;
            height: 320px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 10px;
        }

        #chart_feature {
            width: 100%;
            height: 360px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 10px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(720px, 1fr));
            gap: 12px;
        }

        .chart-panel {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 8px;
            background: #fff;
        }

        .chart-title {
            font-size: 12px;
            color: #6b7280;
            margin: 0 0 4px 2px;
        }

        .chart-canvas {
            width: 100%;
            height: 360px; /* åŸå§‹ä»·æ ¼æ¯ä¸ªå­å›¾çš„é«˜åº¦ */
        }

        .feature-canvas {
            width: 100%;
            height: 300px; /* ç‰¹å¾å›¾æ¯ä¸ªå­å›¾çš„é«˜åº¦ */
        }

        .chart-wrap {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .chart-title .chip {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 9999px;
            background: #f3f4f6;
            color: #111827;
            border: 1px solid #e5e7eb;
        }

        .chart-box {
            width: 100%;
            height: 360px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
        }

        /* æ‰€æœ‰åˆ†å›¾çš„ç”»å¸ƒï¼šæŠ¬é«˜åˆ° 420pxï¼ˆå¯æŒ‰éœ€ 360~520ï¼‰ */
        .chart-panel .chart-canvas,
        .chart-panel .feature-canvas,
        .chart-panel .chart-box {
            height: 650px;
        }

        /* å¦‚æœä¸»å›¾ä¸æ˜¯ç½‘æ ¼å®¹å™¨è€Œæ˜¯å•ä¸€ç”»å¸ƒï¼ˆ#chart æ²¡æœ‰ .chart-gridï¼‰ */
        #chart:not(.chart-grid) {
            height: 600px;
        }

        #chart:not(.chart-grid) {
            height: 600px;
        }

        /* é¿å…å¤–å±‚è£å‰ªåæ ‡è½´æ ‡ç­¾ */
        .chart-panel,
        .chart-panel .chart-box {
            overflow: visible;
        }

        @media (max-width: 992px) {
            .chart-panel .chart-canvas,
            .chart-panel .feature-canvas,
            .chart-panel .chart-box {
                height: 600px;
            }

            #chart:not(.chart-grid) {
                height: 650px;
            }
        }

    </style>

</head>
<body>
<div class="wrap">
    <h2 style="margin:6px 0 12px">åº—èˆ—æ¨ªæ–­ä¾¡æ ¼æ›²ç·š</h2>


    <fieldset style="margin-top:12px">
        <legend>é¸æŠæ¡ä»¶</legend>
        <div class="row4">
            <div>
                <label>iPhoneã®å‹ç•ªï¼ˆPart Numberï¼‰</label>
                <input id="iphone" list="iphone-list" type="text" placeholder="ä¾‹ï¼šMG864J/Aï¼ˆãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‹ã‚‰é¸æŠå¯ï¼‰"/>
                <datalist id="iphone-list"></datalist>
            </div>

            <div>
                <label>æ™‚é–“ç¯„å›² é–‹å§‹ï¼ˆJSTï¼‰</label>
                <input id="start" type="datetime-local" step="60">
            </div>
            <div>
                <label>æ™‚é–“ç¯„å›² çµ‚äº†ï¼ˆJSTï¼‰<span>è‡ªå‹•æ›´æ–°</span></label>
                <input id="end" type="datetime-local" step="60">
            </div>
        </div>

        <div style="margin-top:10px">
            <label>åº—èˆ—</label>
            <div id="shops"></div>
            <div class="btns" style="margin-top:8px">
                <button class="ghost" id="select-all" type="button">ã™ã¹ã¦é¸æŠ</button>
                <button class="ghost" id="clear-all" type="button">ã™ã¹ã¦è§£é™¤</button>
            </div>
        </div>

        <div class="btns" style="margin:10px 0 8px">
            <button id="load" type="button">èª­ã¿è¾¼ã¿ãƒ»æç”»</button>
            <button id="reset" class="secondary" type="button">è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ</button>
            <span id="status" class="muted"></span><span id="err" class="error"></span>
        </div>

        <br>

    </fieldset>

    <!-- ===== äº”ç§ç»„åˆï¼ˆå…¨éƒ¨å•é€‰ï¼ŒåŸå§‹ä»·æ ¼ç‰ˆï¼‰ ===== -->
    <fieldset>
        <legend>äº”ç§ç»„åˆ</legend>

        <!-- ===== ç»„ Aï¼šå„åº— Ã— å„ iPhone ===== -->
        <p>ãƒ‘ã‚¿ãƒ¼ãƒ³ã€€Aã€€ :ã€€å˜ä¸€åº—èˆ—ã€€xã€€å˜ä¸€iPhone</p>
        <div class="row4" style="margin-top:14px">

            <!-- A-1 åº—é“ºï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>A) å˜ä¸€åº—èˆ—</label>
                <div style="display:flex;align-items:center;gap:8px;max-width:520px">
                    <span id="sA_shop_swatch"
                          style="display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #d1d5db;background:#999"></span>
                    <input id="sA_shop" list="sA_shop_list" type="text" placeholder="ä¾‹ï¼šè²·å–å•†åº— (#14)"
                           autocomplete="off" style="flex:1"/>
                    <datalist id="sA_shop_list"></datalist>
                </div>
                <div class="muted" id="sA_shop_hint" style="margin-top:4px">åº—èˆ— å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sA_shop_id" type="hidden"/>
            </div>

            <!-- A-2 iPhoneï¼ˆPart Number å•é€‰ï¼‰ -->
            <div>
                <label>A) å˜ä¸€iPhone</label>
                <input id="sA_part" list="sA_part_list" type="text" placeholder="ä¾‹ï¼šMG864J/A" autocomplete="off"
                       style="max-width:520px"/>
                <datalist id="sA_part_list"></datalist>
                <div class="muted" id="sA_part_hint" style="margin-top:4px">iPhone å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sA_iphone_id" type="hidden"/>
            </div>


            <div style="display:flex;align-items:flex-end">
                <button id="btn_load_A" type="button">èª­ã¿è¾¼ã¿ï¼ˆAï¼‰</button>
            </div>
        </div>

        <!-- ===== ç»„ Bï¼šå…¨éƒ¨åº— Ã— ç»„åˆ iPhone ===== -->
        <p>ãƒ‘ã‚¿ãƒ¼ãƒ³ã€€Bã€€ :ã€€å…¨åº—èˆ—ã€€xã€€iPhoneçµ„åˆã›</p>
        <div class="row4" style="margin-top:14px">
            <div>
                <label>B) iPhoneçµ„åˆã›</label>
                <input id="sB_cohort" list="sB_cohort_list" type="text" placeholder="ä¾‹ï¼šiPhone 17 256GB (#1)"
                       autocomplete="off" style="max-width:520px"/>
                <datalist id="sB_cohort_list"></datalist>
                <div class="muted" id="sB_cohort_hint" style="margin-top:4px">çµ„åˆã› å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sB_cohort_id" type="hidden"/>
            </div>
            <div aria-hidden="true"></div>

            <div style="display:flex;align-items:flex-end">
                <button id="btn_load_B" type="button">èª­ã¿è¾¼ã¿ï¼ˆBï¼‰</button>
            </div>
        </div>

        <!-- ===== ç»„ Cï¼šç»„åˆåº— Ã— å„ iPhone ===== -->
        <p>ãƒ‘ã‚¿ãƒ¼ãƒ³ã€€Cã€€ :ã€€åº—èˆ—çµ„åˆã›ã€€xã€€å˜ä¸€iPhone</p>
        <div class="row4" style="margin-top:14px">
            <!-- C-1 ç»„åˆåº—ï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>C) åº—èˆ—çµ„åˆã›</label>
                <div style="display:flex;align-items:center;gap:8px;max-width:520px">
                    <span id="sC_profile_swatch"
                          style="display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #d1d5db;background:#999"></span>
                    <input id="sC_profile" list="sC_profile_list" type="text" placeholder="ä¾‹ï¼šæ ¸å¿ƒåº—é“ºç»„åˆ (#1)"
                           autocomplete="off" style="flex:1"/>
                    <datalist id="sC_profile_list"></datalist>
                </div>
                <div class="muted" id="sC_profile_hint" style="margin-top:4px">åº—èˆ—çµ„åˆ å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sC_profile_id" type="hidden"/>
            </div>

            <!-- C-2 iPhoneï¼ˆPart Number å•é€‰ï¼‰ -->
            <div>
                <label>C) å˜ä¸€iPhone</label>
                <input id="sC_part" list="sC_part_list" type="text" placeholder="ä¾‹ï¼šMG864J/A" autocomplete="off"
                       style="max-width:520px"/>
                <datalist id="sC_part_list"></datalist>
                <div class="muted" id="sC_part_hint" style="margin-top:4px">iPhone å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sC_iphone_id" type="hidden"/>
            </div>

            <div style="display:flex;align-items:flex-end">
                <button id="btn_load_C" type="button">èª­ã¿è¾¼ã¿ï¼ˆCï¼‰</button>
            </div>
        </div>

        <!-- ===== ç»„ Dï¼šå„åº— Ã— ç»„åˆ iPhone ===== -->
        <p>ãƒ‘ã‚¿ãƒ¼ãƒ³ã€€Dã€€ :ã€€å˜ä¸€åº—èˆ—ã€€xã€€iPhoneçµ„åˆã›</p>
        <div class="row4" style="margin-top:14px">
            <!-- D-1 åº—é“ºï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>D) å˜ä¸€åº—èˆ—</label>
                <div style="display:flex;align-items:center;gap:8px;max-width:520px">
                    <span id="sD_shop_swatch"
                          style="display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #d1d5db;background:#999"></span>
                    <input id="sD_shop" list="sD_shop_list" type="text" placeholder="ä¾‹ï¼šè²·å–å•†åº— (#14)"
                           autocomplete="off" style="flex:1"/>
                    <datalist id="sD_shop_list"></datalist>
                </div>
                <div class="muted" id="sD_shop_hint" style="margin-top:4px">åº—èˆ— å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sD_shop_id" type="hidden"/>
            </div>

            <!-- D-2 ç»„åˆ iPhoneï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>D) iPhoneçµ„åˆã›</label>
                <input id="sD_cohort" list="sD_cohort_list" type="text" placeholder="ä¾‹ï¼šiPhone 17 256GB (#1)"
                       autocomplete="off" style="max-width:520px"/>
                <datalist id="sD_cohort_list"></datalist>
                <div class="muted" id="sD_cohort_hint" style="margin-top:4px">çµ„åˆã› å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sD_cohort_id" type="hidden"/>
            </div>

            <div style="display:flex;align-items:flex-end">
                <button id="btn_load_D" type="button">èª­ã¿è¾¼ã¿ï¼ˆDï¼‰</button>
            </div>
        </div>

        <!-- ===== ç»„ Eï¼šç»„åˆåº— Ã— ç»„åˆ iPhone ===== -->
        <p>ãƒ‘ã‚¿ãƒ¼ãƒ³ã€€Eã€€ :ã€€åº—èˆ—çµ„åˆã›ã€€xã€€iPhoneçµ„åˆã›</p>
        <div class="row4" style="margin-top:14px">
            <!-- E-1 ç»„åˆåº—ï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>E) åº—èˆ—çµ„åˆã›</label>
                <div style="display:flex;align-items:center;gap:8px;max-width:520px">
                    <span id="sE_profile_swatch"
                          style="display:inline-block;width:14px;height:14px;border-radius:3px;border:1px solid #d1d5db;background:#999"></span>
                    <input id="sE_profile" list="sE_profile_list" type="text" placeholder="ä¾‹ï¼šæ ¸å¿ƒåº—é“ºç»„åˆ (#1)"
                           autocomplete="off" style="flex:1"/>
                    <datalist id="sE_profile_list"></datalist>
                </div>
                <div class="muted" id="sE_profile_hint" style="margin-top:4px">åº—èˆ—çµ„åˆ å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sE_profile_id" type="hidden"/>
            </div>

            <!-- E-2 ç»„åˆ iPhoneï¼ˆå•é€‰ï¼‰ -->
            <div>
                <label>E) iPhoneçµ„åˆã›</label>
                <input id="sE_cohort" list="sE_cohort_list" type="text" placeholder="ä¾‹ï¼šiPhone 17 256GB (#1)"
                       autocomplete="off" style="max-width:520px"/>
                <datalist id="sE_cohort_list"></datalist>
                <div class="muted" id="sE_cohort_hint" style="margin-top:4px">çµ„åˆã› å€™è£œã‚’èª­ã¿è¾¼ã¿ä¸­â€¦</div>
                <input id="sE_cohort_id" type="hidden"/>
            </div>

            <div style="display:flex;align-items:flex-end">
                <button id="btn_load_E" type="button">èª­ã¿è¾¼ã¿ï¼ˆEï¼‰</button>
            </div>
        </div>
    </fieldset>

    {# æ•°æ®è¡¨ #}
    <div id="chart"></div>

    {# 3Dæ•£ç‚¹å›¾ - æŒ‰é¢œè‰²åˆ†ç»„ #}
    <div id="chart_3d_container">
        <fieldset>
            <legend>3Dä¾¡æ ¼åˆ†å¸ƒï¼ˆã‚«ãƒ©ãƒ¼åˆ¥ï¼‰</legend>
            <div id="chart_3d_grid" class="chart-3d-grid"></div>
        </fieldset>
    </div>

    {# æ°”æ³¡å›¾ - æŒ‰é¢œè‰²åˆ†ç»„ï¼Œ3å°æ—¶èšåˆ #}
    <div id="chart_bubble_container">
        <fieldset>
            <legend>ä¾¡æ ¼åˆ†å¸ƒãƒãƒ–ãƒ«ãƒãƒ£ãƒ¼ãƒˆï¼ˆ3æ™‚é–“é›†è¨ˆãƒ»ã‚«ãƒ©ãƒ¼åˆ¥ï¼‰</legend>
            <div id="chart_bubble_grid" class="chart-bubble-grid"></div>
        </fieldset>
    </div>

    {# å‰ç«¯åŸºç¡€ç»Ÿè®¡ #}
    <div id="chart_stats"></div>
    {# åç«¯è®¡ç®—ç»Ÿè®¡ä¿¡æ¯ #}
    <div id="chart_feature"></div>

</div>

<script>
/* ========================================
 * ğŸ“‹ è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (Configuration Parameters)
 * ======================================== */

/* ========== API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ (API Endpoints) ========== */

/** WebSocketé€šçŸ¥URL */
const BROADCAST_URL = '/events/notify_progress_all';

/** åº—èˆ—ä¸€è¦§å–å¾—API */
const ENDPOINT_SHOPS = `/AppleStockChecker/secondhand-shops/`;

/** iPhoneå‹ç•ªä¸€è¦§å–å¾—API */
const ENDPOINT_IPHONES = `/AppleStockChecker/iphones/`;

/** åŸå§‹ä¾¡æ ¼æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿API (ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆç‰ˆ) */
const SERIES_API_BASE = '/AppleStockChecker/purchasing-time-analyses-psta-compact/';

/** Feature ãƒã‚¤ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿API */
const FEATURE_SERIES_API = '/AppleStockChecker/features/points/';

/** Scopes (åº—èˆ—ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»iPhoneã‚³ãƒ›ãƒ¼ãƒˆ) å–å¾—API */
const ENDPOINT_SCOPES = '/AppleStockChecker/options/scopes/';

/* ========== æ™‚é–“ãƒ»ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³è¨­å®š (Time & Timezone) ========== */

/** JST (æ—¥æœ¬æ¨™æº–æ™‚) ã‚ªãƒ•ã‚»ãƒƒãƒˆ: +09:00 ã®ãƒŸãƒªç§’è¡¨ç¾ */
const JST_OFFSET_MS = 9 * 60 * 60 * 1000;

/** 1æ—¥ã®ãƒŸãƒªç§’æ•° */
const ONE_DAY = 24 * 3600 * 1000;

/* ========== ä¾¡æ ¼ãƒ•ã‚£ãƒ«ã‚¿è¨­å®š (Price Filter) ========== */

/** è¡¨ç¤ºå¯¾è±¡ã®æœ€å°ä¾¡æ ¼ (å††) - ã“ã‚Œä»¥ä¸‹ã¯ç•°å¸¸å€¤ã¨ã—ã¦é™¤å¤– */
const PRICE_VISIBLE_MIN = 100000;  // 10ä¸‡å††

/** è¡¨ç¤ºå¯¾è±¡ã®æœ€å¤§ä¾¡æ ¼ (å††) - ã“ã‚Œä»¥ä¸Šã¯ç•°å¸¸å€¤ã¨ã—ã¦é™¤å¤– */
const PRICE_VISIBLE_MAX = 400000;  // 40ä¸‡å††

/* ========== ãƒãƒ£ãƒ¼ãƒˆè¡¨ç¤ºè¨­å®š (Chart Display) ========== */

/** Yè»¸ã®ä¸Šä¸‹ç•™ç™½æ¯”ç‡ (0.1 = 10%) - ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã®ä¸Šä¸‹ã«è¦–è¦šçš„ãªä½™ç™½ã‚’è¿½åŠ  */
const YPAD_RATIO = 0.1;

/* ========== ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒåˆ¶å¾¡ (Data Fetch Control) ========== */

/** ä¸€åº¦ã«æç”»ã™ã‚‹æœ€å¤§ç³»åˆ—æ•° (ã“ã‚Œä»¥ä¸Šã¯åˆ‡ã‚Šæ¨ã¦) */
const RAW_MAX_SERIES = 60;

/** ä¸¦è¡Œãƒ•ã‚§ãƒƒãƒã®æœ€å¤§åŒæ™‚å®Ÿè¡Œæ•° */
const RAW_CONC_LIMIT = 8;

/* ========== ãƒ‡ãƒ¼ã‚¿é›†ç´„è¨­å®š (Data Aggregation) ========== */

/**
 * ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿é›†ç´„æ™‚ã®æ™‚é–“çª“å£ï¼ˆãƒŸãƒªç§’ï¼‰
 *
 * è¤‡æ•°ç³»åˆ—ã‚’å¹³å‡åŒ–ã™ã‚‹éš›ã€ã“ã®æ™‚é–“çª—å£å†…ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’1ã¤ã®ãƒã‚±ãƒƒãƒˆã¨ã—ã¦é›†ç´„ã—ã¾ã™ã€‚
 *
 * æ¨å¥¨å€¤:
 * - 60000 (1åˆ†): åˆ†å˜ä½ã®ãƒ‡ãƒ¼ã‚¿ã§ç´°ã‹ã„å¤‰å‹•ã‚’è¦‹ãŸã„å ´åˆ
 * - 300000 (5åˆ†): çŸ­æœŸçš„ãªãƒã‚¤ã‚ºã‚’å¹³æ»‘åŒ–
 * - 600000 (10åˆ†): ä¸­ç¨‹åº¦ã®å¹³æ»‘åŒ–
 * - 1800000 (30åˆ†): é•·æœŸçš„ãªãƒˆãƒ¬ãƒ³ãƒ‰ã‚’è¦‹ã‚‹å ´åˆ
 * - 3600000 (1æ™‚é–“): ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªæ›²ç·š
 *
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 300000 (5åˆ†)
 *
 * å€¤ãŒå°ã•ã„ã»ã©:
 * - âœ… ç´°ã‹ã„å¤‰å‹•ã‚’æ‰ãˆã‚‰ã‚Œã‚‹
 * - âŒ ãƒã‚¤ã‚ºãŒå¤šãã€æ³¢å‹•ãŒæ¿€ã—ããªã‚‹
 *
 * å€¤ãŒå¤§ãã„ã»ã©:
 * - âœ… æ»‘ã‚‰ã‹ãªæ›²ç·šã«ãªã‚‹
 * - âŒ çŸ­æœŸçš„ãªå¤‰å‹•ã‚’è¦‹é€ƒã™å¯èƒ½æ€§ãŒã‚ã‚‹
 */
const AGG_TIME_WINDOW_MS = 15 * 60 * 1000;  // 5åˆ† (300000ãƒŸãƒªç§’)

/* ========== ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ (Color Palette) ========== */

/**
 * åº—èˆ—åˆ¥ã‚«ãƒ©ãƒ¼ãƒ«ãƒ¼ãƒ«
 * å„åº—èˆ—ã«å›ºå®šè‰²ã¨è¡¨ç¤ºé †åºã‚’å‰²ã‚Šå½“ã¦
 * @type {Array<{match: RegExp, color: string, shop_id: number, order: number}>}
 */
const SHOP_COLOR_RULES = [
    {match: /è²·å–å•†åº—/, color: "#DD1133", shop_id: 14, order: 1},
    {match: /æµ·å³¡é€šä¿¡/, color: "#478CD8", shop_id: 1, order: 2},
    {match: /è²·å–ä¸€ä¸ç›®/, color: "#B41524", shop_id: 8, order: 3},
    {match: /ãƒ¢ãƒã‚¤ãƒ«ãƒŸãƒƒã‚¯ã‚¹/, color: "#DD1133", shop_id: 13, order: 4},
    {match: /æ£®æ£®è²·å–/, color: "#278C46", shop_id: 7, order: 5},
    {match: /è²·å–ãƒ«ãƒ‡ãƒ¤/, color: "#2DA9E8", shop_id: 9, order: 6},
    {match: /è²·å–wiki/, color: "#E71534", shop_id: 10, order: 7},
    {match: /è²·å–ãƒ›ãƒ ãƒ©/, color: "#F27474", shop_id: 19, order: 8},
    {match: /ãƒ‰ãƒ©ã‚´ãƒ³ãƒ¢ãƒã‚¤ãƒ«/, color: "#3952A6", shop_id: 16, order: 9},
    {match: /ãƒ¢ãƒã‚¹ãƒ†/, color: "#E60012", shop_id: 18, order: 10},
    {match: /ã‚¢ã‚­ãƒ¢ãƒ/, color: "#20AECC", shop_id: 12, order: 11},
    {match: /ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«/, color: "#0EC7D9", shop_id: 17, order: 12},
    {match: /å®¶é›»å¸‚å ´/, color: "#FFF100", shop_id: 3, order: 13},
    {match: /è²·å–æ¥½åœ’/, color: "#DA7C66", shop_id: 4, order: 14},
    {match: /è²·å–å½“ç•ª/, color: "#1C4473", shop_id: 2, order: 15},
    {match: /æºå¸¯ç©ºé–“/, color: "#0049A8", shop_id: 5, order: 16},
    {match: /ã‚²ã‚¹ãƒˆãƒ¢ãƒã‚¤ãƒ«/, color: "#34C6F6", shop_id: 11, order: 17},
    {match: /è²·å–ã‚ªã‚¯/, color: "#033F68", shop_id: 6, order: 18},
    {match: /æ¯æ—¥è²·å–/, color: "#C30D23", shop_id: 15, order: 19},
    {match: /Mobile Zone/, color: "#f50620", shop_id: 20, order: 20},
];

/**
 * ç³»åˆ—æç”»ç”¨ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
 * Feature ãƒ©ã‚¤ãƒ³ã‚„è¤‡æ•°ç³»åˆ—ã®è‰²åˆ†ã‘ã«ä½¿ç”¨
 * @type {string[]}
 */
const LINE_PALETTE = [
    "#478CD8", "#E71534", "#278C46", "#2DA9E8", "#F27474",
    "#3952A6", "#E60012", "#20AECC", "#0EC7D9", "#FFF100",
    "#DA7C66", "#1C4473", "#0049A8", "#34C6F6", "#033F68",
    "#C30D23", "#f50620", "#7e57c2", "#26a69a", "#ef6c00"
];

/* ========== Feature ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š (Feature Defaults) ========== */


/* ========================================
 * ğŸŒ ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ (Global State)
 * ======================================== */

/* ========== ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ (Data Indexes) ========== */

/** åº—èˆ—IDã‹ã‚‰åº—èˆ—åã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚° @type {Map<number, string>} */
const SHOPS_INDEX = new Map();

/** Part Numberã‹ã‚‰iPhone IDã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚° @type {Map<string, number>} */
const IPHONE_ID_BY_PART = new Map();

/** Part Numberã‹ã‚‰iPhoneè©³ç´°æƒ…å ±ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚° @type {Map<string, Object>} */
const IPHONE_INFO_BY_PART = new Map();

/* ========== Scopes ãƒ‡ãƒ¼ã‚¿ (Scope Data) ========== */

/**
 * åº—èˆ—ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§
 * å„ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¯è¤‡æ•°åº—èˆ—ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸã‚‚ã®
 * @type {Array<{id: number, slug: string, title: string, label: string, items: Array<{shop_id: number, shop_name: string}>}>}
 */
let SHOP_PROFILES = [];

/**
 * iPhoneã‚³ãƒ›ãƒ¼ãƒˆä¸€è¦§
 * å„ã‚³ãƒ›ãƒ¼ãƒˆã¯è¤‡æ•°ã®iPhoneå‹ç•ªã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸã‚‚ã®
 * @type {Array<{id: number, slug: string, title: string, label: string, members: Array<{iphone_id: number, part_number: string}>}>}
 */
let COHORTS = [];

/** ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«IDã‹ã‚‰ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚° @type {Map<number, Object>} */
let PROFILE_BY_ID = new Map();

/** ã‚³ãƒ›ãƒ¼ãƒˆIDã‹ã‚‰ã‚³ãƒ›ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚° @type {Map<number, Object>} */
let COHORT_BY_ID = new Map();

/** Scopes APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ (1å›ã®ã¿ãƒ•ã‚§ãƒƒãƒ) @type {Object|null} */
let _SCOPES_CACHE = null;

/* ========== ç¾åœ¨ã®é¸æŠçŠ¶æ…‹ (Current Selection State) ========== */

/** ç¾åœ¨é¸æŠä¸­ã® Part Number @type {string} */
let ACTIVE_PART_NUMBER = '';

/** ç¾åœ¨é¸æŠä¸­ã® iPhone ID @type {number|null} */
let ACTIVE_IPHONE_ID = null;

/** ç¾åœ¨é¸æŠä¸­ã®åº—èˆ—IDã‚»ãƒƒãƒˆ @type {Set<number>} */
let SELECTED_SHOP_IDS = new Set();

/** ç¾åœ¨é¸æŠä¸­ã®é–‹å§‹æ™‚åˆ» (UTC ãƒŸãƒªç§’) @type {number|null} */
let SELECTED_START_MS = null;

/** ç¾åœ¨é¸æŠä¸­ã®çµ‚äº†æ™‚åˆ» (UTC ãƒŸãƒªç§’) @type {number|null} */
let SELECTED_END_MS = null;

/* ========== ã‚¿ã‚¤ãƒãƒ¼ (Timers) ========== */

/** çµ‚äº†æ™‚åˆ»è‡ªå‹•åŒæœŸã‚¿ã‚¤ãƒãƒ¼ID @type {number|null} */
let END_AUTO_TIMER = null;

/* ========================================
 * ğŸ› ï¸ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° (Utility Functions)
 * ======================================== */

/* ========== DOMæ“ä½œ (DOM Manipulation) ========== */

/**
 * getElementById ã®ã‚·ãƒ§ãƒ¼ãƒˆãƒãƒ³ãƒ‰
 * @param {string} id - è¦ç´ ID
 * @returns {HTMLElement|null} DOMè¦ç´ 
 */
const $ = id => document.getElementById(id);

/* ========== æ—¥ä»˜ãƒ»æ™‚åˆ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Date & Time Utilities) ========== */

/**
 * UTC ãƒŸãƒªç§’ã‚’ JST ã® Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
 *
 * ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã«å½±éŸ¿ã•ã‚Œãšã«ã€å¸¸ã« JST (+09:00) ã¨ã—ã¦
 * æ—¥æ™‚ã‚’æ‰±ã†ãŸã‚ã®å¤‰æ›é–¢æ•°ã€‚å¤‰æ›å¾Œã® Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ getUTC* ãƒ¡ã‚½ãƒƒãƒ‰ã§
 * JST ã®å¹´æœˆæ—¥æ™‚åˆ†ç§’ã‚’å–å¾—å¯èƒ½ã€‚
 *
 * @param {number} ms - UTC ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)
 * @returns {Date} JST ã‚ªãƒ•ã‚»ãƒƒãƒˆé©ç”¨å¾Œã® Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @example
 * const jstDate = utcMsToJstDate(1640995200000);
 * console.log(jstDate.getUTCHours()); // JST ã®æ™‚åˆ»ã‚’å–å¾—
 */

function utcMsToJstDate(ms) {
    return new Date(ms + JST_OFFSET_MS);
}

/**
 * æ—¥ä»˜ã‚’ãã®æ—¥ã®0æ™‚0åˆ†0ç§’ã«åˆ‡ã‚Šä¸‹ã’
 *
 * @param {number} ms - UTC ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)
 * @returns {number|null} 0æ™‚ã«åˆ‡ã‚Šä¸‹ã’ãŸã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€ç„¡åŠ¹ãªå…¥åŠ›ã®å ´åˆã¯null
 * @example
 * const ms = Date.now();
 * const dayStart = floorDay(ms); // ãã®æ—¥ã®00:00:00
 */
function floorDay(ms) {
    if (!Number.isFinite(ms)) return null;
    const d = new Date(ms);
    d.setHours(0, 0, 0, 0);
    return d.getTime();
}

/**
 * æ—¥ä»˜ã‚’æ¬¡ã®æ—¥ã®0æ™‚0åˆ†0ç§’ã«åˆ‡ã‚Šä¸Šã’
 *
 * @param {number} ms - UTC ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)
 * @returns {number|null} æ¬¡ã®æ—¥ã®0æ™‚ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€ç„¡åŠ¹ãªå…¥åŠ›ã®å ´åˆã¯null
 * @example
 * const ms = Date.now();
 * const nextDay = ceilDay(ms); // ç¿Œæ—¥ã®00:00:00
 */
function ceilDay(ms) {
    if (!Number.isFinite(ms)) return null;
    const d = new Date(ms);
    d.setHours(0, 0, 0, 0);
    return d.getTime() + ONE_DAY;
}

/**
 * ISOæ–‡å­—åˆ—ã‚’UTCãƒŸãƒªç§’ã«å¤‰æ›
 *
 * @param {string} s - ISO 8601å½¢å¼ã®æ—¥æ™‚æ–‡å­—åˆ—
 * @returns {number} ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)ã€ç„¡åŠ¹ãªå…¥åŠ›ã®å ´åˆã¯NaN
 * @example
 * const ms = toMillis('2025-01-20T10:00:00Z');
 */
function toMillis(s) {
    const t = new Date(s).valueOf();
    return Number.isFinite(t) ? t : NaN;
}

/**
 * ãƒ­ãƒ¼ã‚«ãƒ«JSTæ–‡å­—åˆ— (datetime-localå½¢å¼) ã‚’ISO UTCæ–‡å­—åˆ—ã«å¤‰æ›
 *
 * ãƒ•ã‚©ãƒ¼ãƒ ã® datetime-local å…¥åŠ›å€¤ (ä¾‹: "2025-10-20T10:00") ã‚’
 * JST ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ ã¨ã—ã¦è§£é‡ˆã—ã€UTC ã® ISOæ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã€‚
 *
 * @param {string} dtStr - "YYYY-MM-DDTHH:MM" å½¢å¼ã®æ–‡å­—åˆ— (JSTæƒ³å®š)
 * @returns {string} ISO 8601 UTCæ–‡å­—åˆ— (ä¾‹: "2025-10-20T01:00:00Z")ã€ç„¡åŠ¹ãªå…¥åŠ›ã®å ´åˆã¯ç©ºæ–‡å­—åˆ—
 * @example
 * const utcIso = toIsoLocal("2025-10-20T10:00");
 * // => "2025-10-20T01:00:00Z" (JST 10:00 = UTC 01:00)
 */
function toIsoLocal(dtStr) {
    if (!dtStr || !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(dtStr)) return '';
    return new Date(`${dtStr}:00+09:00`).toISOString().replace('.000Z', 'Z');
}

/**
 * æœ€ã‚‚è¿‘ã„éå»ã®åˆ†ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—
 *
 * @param {Date} [d=new Date()] - åŸºæº–ã¨ãªã‚‹æ—¥æ™‚
 * @returns {number} åˆ†å˜ä½ã«åˆ‡ã‚Šä¸‹ã’ãŸã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)
 * @example
 * const ms = nearestPastMinuteMs(); // ç¾åœ¨æ™‚åˆ»ã®ç§’ä»¥ä¸‹ã‚’åˆ‡ã‚Šæ¨ã¦
 */
function nearestPastMinuteMs(d = new Date()) {
    return Math.floor(d.getTime() / 60000) * 60000;
}

/**
 * åˆ†å˜ä½ã«åˆ‡ã‚Šä¸‹ã’ãŸ Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™
 *
 * @param {Date} [date=new Date()] - åŸºæº–ã¨ãªã‚‹æ—¥æ™‚
 * @returns {Date} ç§’ãƒ»ãƒŸãƒªç§’ãŒ0ã«ã‚»ãƒƒãƒˆã•ã‚ŒãŸ Date
 * @example
 * const floored = floorToMinute(new Date());
 */
function floorToMinute(date = new Date()) {
    return new Date(Math.floor(date.getTime() / 60000) * 60000);
}

/**
 * UTC Date ã‚’ JST ã® datetime-local å…¥åŠ›å€¤å½¢å¼ã«å¤‰æ›
 *
 * @param {Date} dateUtc - UTC ã® Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns {string} "YYYY-MM-DDTHH:MM" å½¢å¼ã®æ–‡å­—åˆ— (JST)
 * @example
 * const inputValue = toInputValueJST(new Date());
 * // => "2025-11-26T15:30" (JST)
 */
function toInputValueJST(dateUtc) {
    const msJst = dateUtc.getTime() + JST_OFFSET_MS;
    const d = new Date(msJst);
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth() + 1).padStart(2, '0');
    const day = String(d.getUTCDate()).padStart(2, '0');
    const hh = String(d.getUTCHours()).padStart(2, '0');
    const mm = String(d.getUTCMinutes()).padStart(2, '0');
    return `${y}-${m}-${day}T${hh}:${mm}`;
}

/**
 * æœ€ã‚‚è¿‘ã„éå»ã®åˆ†ã‚’ JST ã® datetime-local å…¥åŠ›å€¤å½¢å¼ã§å–å¾—
 *
 * @returns {string} "YYYY-MM-DDTHH:MM" å½¢å¼ã®æ–‡å­—åˆ— (JST)
 * @example
 * const value = nearestPastMinuteInputValueJST();
 * // => "2025-11-26T15:30" (ç¾åœ¨æ™‚åˆ»ã‹ã‚‰ç§’ä»¥ä¸‹åˆ‡ã‚Šæ¨ã¦ã€JST)
 */
function nearestPastMinuteInputValueJST() {
    const flooredUtc = floorToMinute(new Date());
    return toInputValueJST(flooredUtc);
}

/**
 * ç¸¦æ›¸ãæ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ (ECharts Xè»¸ç”¨)
 *
 * UTC ãƒŸãƒªç§’ã‚’ JST ã® "æœˆ\næ—¥\n(æ›œ)" å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 *
 * @param {number} ms - UTC ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ— (ãƒŸãƒªç§’)
 * @returns {string} æ”¹è¡ŒåŒºåˆ‡ã‚Šã®ç¸¦æ›¸ãæ—¥ä»˜æ–‡å­—åˆ—
 * @example
 * const label = verticalTickFormatter(1640995200000);
 * // => "1\næœˆ\n1æ—¥\n(åœŸ)"
 */
function verticalTickFormatter(ms) {
    const d = utcMsToJstDate(ms);
    const m = d.getUTCMonth() + 1;
    const day = d.getUTCDate();
    const w = WDAY[d.getUTCDay()];
    return `${m}\næœˆ\n${day}æ—¥\nï¼ˆ${w}ï¼‰`;
}

/* ========== ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Format Utilities) ========== */

/**
 * æ•°å€¤ã‚’æ—¥æœ¬å††é€šè²¨å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 *
 * @param {number} n - é‡‘é¡
 * @returns {string} "Â¥123,456" å½¢å¼ã®æ–‡å­—åˆ—
 * @example
 * fmtJPY(123456); // => "Â¥123,456"
 */
const fmtJPY = n => new Intl.NumberFormat('ja-JP', {
    style: 'currency',
    currency: 'JPY',
    maximumFractionDigits: 0
}).format(n);

/** æ›œæ—¥é…åˆ— (æ—¥æ›œ=0 ã€œ åœŸæ›œ=6) */
const WDAY = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];

/**
 * Part Number ã‹ã‚‰ iPhone ã®äººé–“å¯èª­ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆ
 *
 * IPHONE_INFO_BY_PART ã‹ã‚‰æƒ…å ±ã‚’å–å¾—ã—ã€
 * "ãƒ¢ãƒ‡ãƒ«å å®¹é‡GB è‰²" å½¢å¼ã®æ–‡å­—åˆ—ã‚’è¿”ã™
 *
 * @param {string} pn - iPhone ã® Part Number
 * @returns {string} äººé–“å¯èª­ãƒ©ãƒ™ãƒ«ã€æƒ…å ±ãŒãªã„å ´åˆã¯ Part Number ãã®ã¾ã¾
 * @example
 * iphoneHumanLabelByPart("MG864J/A");
 * // => "iPhone 15 Pro 256GB ãƒŠãƒãƒ¥ãƒ©ãƒ«ãƒã‚¿ãƒ‹ã‚¦ãƒ "
 */
function iphoneHumanLabelByPart(pn) {
    const info = IPHONE_INFO_BY_PART.get(String(pn));
    if (!info) return String(pn);
    const cap = info.capacity_gb ? `${info.capacity_gb}GB` : '';
    const color = info.color ? ` ${info.color}` : '';
    const model = info.model_name || 'iPhone';
    return `${model} ${cap}${color}`.trim();
}

/* ========== çµ±è¨ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Statistics Utilities) ========== */

/**
 * ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰ Y å€¤ã‚’æŠ½å‡º
 *
 * ECharts ã®ãƒ‡ãƒ¼ã‚¿å½¢å¼ ([x, y] ã¾ãŸã¯ {value: [x, y]}) ã‹ã‚‰
 * Yå€¤ (ä¾¡æ ¼ã‚„æ•°å€¤) ã‚’å–ã‚Šå‡ºã™
 *
 * @param {Array|Object} item - ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ
 * @returns {number} Yå€¤ã€å–å¾—ã§ããªã„å ´åˆã¯NaN
 * @example
 * _yOf([1640995200000, 123456]); // => 123456
 * _yOf({value: [1640995200000, 123456]}); // => 123456
 */
function _yOf(item) {
    if (Array.isArray(item)) return Number(item[1]);
    if (item && item.value && Array.isArray(item.value)) return Number(item.value[1]);
    return NaN;
}

/**
 * ç³»åˆ—ã‹ã‚‰æœ€å¾Œã®æœ‰åŠ¹ãª Y å€¤ã‚’å–å¾—
 *
 * ãƒ‡ãƒ¼ã‚¿é…åˆ—ã‚’å¾Œã‚ã‹ã‚‰èµ°æŸ»ã—ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸæœ‰åŠ¹ãªæ•°å€¤ã‚’è¿”ã™
 *
 * @param {Array} data - ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®é…åˆ—
 * @returns {number} æœ€å¾Œã®æœ‰åŠ¹ãªYå€¤ã€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯NaN
 * @example
 * _latestY([[1, 100], [2, 200], [3, NaN]]); // => 200
 */
function _latestY(data) {
    for (let i = data.length - 1; i >= 0; i--) {
        const v = _yOf(data[i]);
        if (Number.isFinite(v)) return v;
    }
    return NaN;
}

/**
 * ã‚½ãƒ¼ãƒˆæ¸ˆã¿æ•°å€¤é…åˆ—ã®ä¸­å¤®å€¤ã‚’è¨ˆç®—
 *
 * @param {number[]} sortedNums - æ˜‡é †ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®æ•°å€¤é…åˆ—
 * @returns {number} ä¸­å¤®å€¤ã€ç©ºé…åˆ—ã®å ´åˆã¯NaN
 * @example
 * _median([1, 2, 3, 4, 5]); // => 3
 * _median([1, 2, 3, 4]); // => 2.5
 */
function _median(sortedNums) {
    const n = sortedNums.length;
    if (!n) return NaN;
    const mid = Math.floor(n / 2);
    return n % 2
        ? sortedNums[mid]
        : (sortedNums[mid - 1] + sortedNums[mid]) / 2;
}

/**
 * ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æœ€åˆã«è¦‹ã¤ã‹ã£ãŸé…åˆ—å€¤ã‚’è¿”ã™
 *
 * è¤‡æ•°ã®ã‚­ãƒ¼å€™è£œã‹ã‚‰é †ã«æ¤œç´¢ã—ã€é…åˆ—ã‚’è¦‹ã¤ã‘ãŸã‚‰è¿”ã™
 *
 * @param {Object} obj - æ¤œç´¢å¯¾è±¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @param {string[]} keys - ã‚­ãƒ¼å€™è£œã®ãƒªã‚¹ãƒˆ
 * @returns {Array} è¦‹ã¤ã‹ã£ãŸé…åˆ—ã€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ç©ºé…åˆ—
 * @example
 * arrFirst({results: [1,2,3]}, ['data', 'results']); // => [1,2,3]
 */
function arrFirst(obj, keys) {
    for (const k of keys) {
        const v = obj && obj[k];
        if (Array.isArray(v)) return v;
    }
    return [];
}

/**
 * Feature ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚­ãƒ¼ã‚’ URL ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«é©ç”¨
 *
 * 'mean' / 'std' ã®å ´åˆã¯ name ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€
 * ãã‚Œä»¥å¤–ã¯ version ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ URL ã«è¿½åŠ 
 *
 * @param {URL} u - URL ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @param {string} metricKey - ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚­ãƒ¼ ('mean', 'std', ã¾ãŸã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·)
 * @example
 * const url = new URL('https://example.com/api');
 * applyFeatureMetricParam(url, 'mean');
 * // url.searchParams => {name: 'mean'}
 */
function applyFeatureMetricParam(u, metricKey) {
    const key = String(metricKey || '').trim();
    const lower = key.toLowerCase();
    if (lower === 'mean' || lower === 'std') {
        u.searchParams.set('name', key);
    } else {
        u.searchParams.set('version', key);
    }
}

/* ========================================
 * ğŸ“Š ãƒãƒ£ãƒ¼ãƒˆè¨­å®šé–¢æ•° (Chart Configuration Functions)
 * ======================================== */

/**
 * Yè»¸ã®è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šã‚’ç”Ÿæˆ
 *
 * ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã«å¿œã˜ã¦è‡ªå‹•çš„ã«Yè»¸ã®æœ€å°å€¤ãƒ»æœ€å¤§å€¤ã‚’èª¿æ•´ã—ã€
 * è¦–è¦šçš„ãªç•™ç™½ (YPAD_RATIO) ã‚’ä¸Šä¸‹ã«è¿½åŠ ã™ã‚‹ã€‚
 * ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§æœ€å°å€¤ãƒ»æœ€å¤§å€¤ã‚’ã‚¯ãƒ©ãƒ³ãƒ—å¯èƒ½ã€‚
 *
 * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³
 * @param {string} [options.name='JPY'] - Yè»¸ã®ãƒ©ãƒ™ãƒ«å
 * @param {string} [options.position='right'] - Yè»¸ã®ä½ç½® ('left' ã¾ãŸã¯ 'right')
 * @param {number[]|null} [options.clamp=null] - [min, max] ã®å½¢ã§Yè»¸ç¯„å›²ã‚’åˆ¶é™
 * @returns {Object} ECharts Yè»¸è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @example
 * const yAxis = makeAutoY({name: 'JPY', position: 'right', clamp: [100000, 400000]});
 */
function makeAutoY({name = 'JPY', position = 'right', clamp = null} = {}) {
        return {
            type: 'value',
            position,
            name,
            scale: true,
            // æ³¨æ„ï¼šmin/max å¯å†™æˆå‡½æ•°ï¼ŒECharts ä¼šåœ¨æ•°æ®æˆ–çª—å£å˜åŒ–æ—¶è°ƒç”¨
            min: function (ext) {
                const span = Math.max(1, (ext.max - ext.min) || 0);
                let v = ext.min - span * YPAD_RATIO;
                if (clamp && Number.isFinite(clamp[0])) v = Math.max(v, clamp[0]);
                return v;
            },
            max: function (ext) {
                const span = Math.max(1, (ext.max - ext.min) || 0);
                let v = ext.max + span * YPAD_RATIO;
                if (clamp && Number.isFinite(clamp[1])) v = Math.min(v, clamp[1]);
                return v;
            }
        };
    }
    /** === Legend è‡ªåŠ¨æ¢è¡Œ -> åŠ¨æ€æŠ¬é«˜ grid.topï¼Œé¿å…é®æŒ¡ === */
function _px(v, fallback = 0) {
  if (typeof v === 'number' && Number.isFinite(v)) return v;
  if (typeof v === 'string' && /^\d+(\.\d+)?px$/.test(v)) return parseFloat(v);
  return fallback;
}
function _legendOpt(inst) {
  const opt = inst.getOption() || {};
  const legends = Array.isArray(opt.legend) ? opt.legend : (opt.legend ? [opt.legend] : []);
  return legends[0] || {};
}
function _gridOpt(inst) {
  const opt = inst.getOption() || {};
  const grids = Array.isArray(opt.grid) ? opt.grid : (opt.grid ? [opt.grid] : [{}]);
  return grids[0] || {};
}
const __measureCtx = (() => {
  const c = document.createElement('canvas');
  c.width = 1; c.height = 1;
  return c.getContext('2d');
})();

/* ä¼°ç®— Legend è¡Œæ•°ï¼ˆåŸºäºå®¹å™¨å®½åº¦ä¸æ¯é¡¹å®½åº¦ï¼‰ï¼Œä¿æŒâ€œå¯æ¢è¡Œâ€çš„è¡Œä¸º */
function estimateLegendRows(inst) {
  const lg = _legendOpt(inst);
  const names = Array.isArray(lg.data) ? lg.data.map(String) : [];
  if (!names.length) return 0;

  const left = _px(lg.left, 10), right = _px(lg.right, 10);
  const avail = Math.max(0, inst.getWidth() - left - right);
  const fontSize = (lg.textStyle && Number(lg.textStyle.fontSize)) || 12;
  const fontFamily = (lg.textStyle && lg.textStyle.fontFamily) || 'sans-serif';
  const iconW = (lg.itemWidth != null ? Number(lg.itemWidth) : 25);
  const gapIconText = 6;                         // å›¾æ ‡ä¸æ–‡å­—ä¹‹é—´çš„å°é—´è·ï¼ˆç»éªŒå€¼ï¼‰
  const itemGap = (lg.itemGap != null ? Number(lg.itemGap) : 10); // é¡¹ä¸é¡¹ä¹‹é—´çš„é—´è·

  const ctx = __measureCtx;
  ctx.font = `${fontSize}px ${fontFamily}`;

  let rows = 1, lineW = 0;
  for (const name of names) {
    const textW = Math.ceil(ctx.measureText(String(name)).width);
    const w = iconW + gapIconText + textW + itemGap;
    if (lineW > 0 && lineW + w > avail) { // æ¢è¡Œ
      rows++;
      lineW = 0;
    }
    lineW += w;
  }
  return rows;
}

/* æ ¹æ®ä¼°ç®—è¡Œæ•°ï¼ŒæŠ¬é«˜ grid.topï¼Œä¿è¯å›¾ä¾‹ä¸ç»˜å›¾åŒºä¸é‡å  */
function adjustGridTopForLegend(inst) {
  try {
    const lg = _legendOpt(inst);
    if (!lg) return;

    const rows = estimateLegendRows(inst);
    if (rows <= 0) return;

    const fontSize = (lg.textStyle && Number(lg.textStyle.fontSize)) || 12;
    const rowH = Math.max((lg.itemHeight != null ? Number(lg.itemHeight) : 14), fontSize + 8);
    const padTop = Array.isArray(lg.padding) ? Number(lg.padding?.[0] || 0) : Number(lg.padding || 0) || 0;
    const padBottom = Array.isArray(lg.padding) ? Number(lg.padding?.[2] || 0) : Number(lg.padding || 0) || 0;
    const legendTop = _px(lg.top, 8);
    const extra = 8; // å›¾ä¾‹ä¸ç»˜å›¾åŒºä¹‹é—´çš„ç¼“å†²

    const needTop = legendTop + padTop + rows * rowH + padBottom + extra;

    const g = _gridOpt(inst);
    const curTop = _px(g.top, 40);
    if (needTop > curTop) {
      inst.setOption({ grid: { ...g, top: needTop } }, { notMerge: false, lazyUpdate: true });
      // è§¦å‘ä¸€æ¬¡ resizeï¼Œé¿å…ç¬¬ä¸€æ¬¡æ¸²æŸ“åå°ºå¯¸è¿Ÿå»¶
      inst.resize();
    }
  } catch (e) {
    console.warn('[legend-top] adjust failed:', e);
  }
}

    // â€”â€” ä»·æ ¼æ˜¾ç¤ºèŒƒå›´ï¼ˆè¿‡æ»¤é˜ˆå€¼ï¼‰ â€”â€”


    // === ç»Ÿè®¡å›¾ï¼šåˆå§‹åŒ– ===
    const statsChart = echarts.init(document.getElementById('chart_stats'));

    const statsBaseOption = {
        animation: false,
        grid: {left: 16, right: 24, top: 45, bottom: 40},
        tooltip: {
            trigger: 'axis',
            axisPointer: {type: 'shadow'},
            formatter: function (params) {
                if (!params?.length) return '';
                const name = params[0].name;
                const s = (statsChart.__statsByName || {})[name];
                if (!s) return name;
                return [
                    `<b>${name}</b>`,
                    `æœ€æ–°: ${fmtJPY(s.latest)}`,
                    `æœ€å°: ${fmtJPY(s.min)}ã€€æœ€å¤§: ${fmtJPY(s.max)}`,
                    `å¹³å‡: ${fmtJPY(s.mean)}ã€€ä¸­ä½æ•°: ${fmtJPY(s.median)}`,
                    `æ ·æœ¬æ•°: ${s.count}`
                ].join('<br>');
            }
        },
        xAxis: {type: 'category', data: [], axisLabel: {interval: 0, rotate: 0}},
        yAxis: makeAutoY({name: 'JPY', position: 'right', clamp: [PRICE_VISIBLE_MIN, PRICE_VISIBLE_MAX]}),
        dataZoom: [
            {type: 'inside', xAxisIndex: [0], filterMode: 'filter'},
            {type: 'slider', xAxisIndex: [0], bottom: -2, height: 12, handleSize: 0, filterMode: 'filter'}
        ],
        series: [{
            name: 'æœ€æ–°ä¾¡æ ¼',
            type: 'bar',
            data: [],
            label: {show: true, position: 'top', formatter: p => fmtJPY(p.value)}
        }]
    };

    statsChart.setOption(statsBaseOption);
    window.addEventListener('resize', () => statsChart.resize());

    // ä»ä¸»å›¾å½“å‰å¯è§æ›²çº¿æå–ç»Ÿè®¡ï¼ˆåªçœ‹ id ä»¥ s:/raw: å¼€å¤´çš„æŠ˜çº¿ï¼‰
    function computeStatsFromMainChart() {
        const opt = chart.getOption();
        let arr = opt.series || [];
        arr = arr.filter(s => s.type === 'line' && /^(s:|raw:)/.test(String(s.id || '')));

        const out = [];
        for (const s of arr) {
            const data = (s.data || []);
            const ys = data.map(_yOf).filter(Number.isFinite);
            if (!ys.length) continue;

            ys.sort((a, b) => a - b);
            const min = ys[0];
            const max = ys[ys.length - 1];
            const sum = ys.reduce((a, b) => a + b, 0);
            const mean = sum / ys.length;
            const median = _median(ys);
            const latest = _latestY(data);

            out.push({
                name: s.name,
                latest,
                min,
                max,
                mean,
                median,
                count: ys.length
            });
        }
        return out;
    }

    function renderStatsChart(stats) {
        const names = stats.map(s => s.name);
        const latestVals = stats.map(s => s.latest);

        const map = {};
        stats.forEach(s => map[s.name] = s);
        statsChart.__statsByName = map;

        const needRotate = names.length > 12;
        statsChart.setOption({
            xAxis: {data: names, axisLabel: {interval: 0, rotate: needRotate ? 35 : 0}},
            series: [{name: 'æœ€æ–°ä¾¡æ ¼', type: 'bar', data: latestVals}]
        }, {notMerge: false, lazyUpdate: true});
    }

    function updateStatsChart() {
        try {
            const stats = computeStatsFromMainChart();
            if (!stats.length) {
                statsChart.setOption(statsBaseOption, true);
            } else {
                renderStatsChart(stats);
            }
        } catch (e) {
            console.warn('[stats] update failed:', e);
        }
    }

    // === ä¸»å›¾ä¸“ç”¨ï¼šæ—¥ç²’åº¦ + ç«–æ’åˆ»åº¦ ===

    function ensureDailyTicks() {
        if (!chart) return;
        ensureDailyTicksOn(chart);
    }

    function applyWorkHoursOverlay(startMs, endMs) {
        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) return;
        const markArea = buildBusinessHoursMarkArea10to19(startMs, endMs);
        chart.setOption({
            series: [{
                id: '__workhours__',
                type: 'line',
                data: [],
                markArea,
                silent: true,
                z: -10
            }]
        }, {notMerge: false, lazyUpdate: true});
    }


    /* ===================== 1) é¢œè‰²/é¡ºåºè§„åˆ™ ===================== */
    const RULE_BY_ID = new Map(SHOP_COLOR_RULES.filter(r => typeof r.shop_id === 'number').map(r => [r.shop_id, r]));

    function getRuleForShop({name, id}) {
        if (id != null && RULE_BY_ID.has(Number(id))) return RULE_BY_ID.get(Number(id));
        for (const r of SHOP_COLOR_RULES) {
            if (r.match?.test?.(name)) return r;
        }
        return null;
    }

    function getOrderForShop({name, id}) {
        const r = getRuleForShop({name, id});
        return (r && typeof r.order === 'number') ? r.order : Number.POSITIVE_INFINITY;
    }

    function getColorForShop({name, id}, idx = 0) {
        const r = getRuleForShop({name, id});
        return r?.color || LINE_PALETTE[idx % LINE_PALETTE.length];
    }

    /* ===================== 2) å›¾è¡¨å®¹å™¨ä¸å·¥å‚ï¼ˆä¸»å›¾ + åˆ†å›¾ï¼‰ ===================== */

    const ChartGrids = {
        // æ¯ä¸ª part ä¸€å¼ å­å›¾ï¼ˆä»·æ ¼/Featureï¼‰
        price: new Map(),   // part -> {el, chart}
        feature: new Map(), // part -> {el, chart}
        hostPrice: null,    // #chart_parts
        hostFeature: null   // #chart_feature
    };

    /* ===================== 3Då›¾è¡¨ç®¡ç† ===================== */

    // 3Då›¾è¡¨å®¹å™¨ç®¡ç† - æŒ‰iPhoneé¢œè‰²åˆ†ç»„
    const Chart3DManager = {
        charts: new Map(),  // iphoneColor -> {el, chart, data}
        host: null,
        dataByColor: new Map() // iphoneColor -> [{timestamp, shopId, shopName, shopColor, price}]
    };

    function init3DChartHost() {
        if (!Chart3DManager.host) {
            Chart3DManager.host = document.getElementById('chart_3d_grid');
        }
        return Chart3DManager.host;
    }

    function create3DPanel(host, iphoneColor, title) {
        const panel = document.createElement('div');
        panel.className = 'chart-3d-panel';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'chart-3d-title';
        titleDiv.textContent = title;

        const canvas = document.createElement('div');
        canvas.className = 'chart-3d-canvas';

        panel.appendChild(titleDiv);
        panel.appendChild(canvas);
        host.appendChild(panel);

        return {panel, canvas};
    }

    function get3DChartForColor(iphoneColor, title) {
        if (!Chart3DManager.charts.has(iphoneColor)) {
            const host = init3DChartHost();
            if (!host) return null;

            const {canvas} = create3DPanel(host, iphoneColor, title);
            const chart = echarts.init(canvas);

            // åŸºç¡€3Dé…ç½®
            const option = {
                tooltip: {
                    formatter: function(params) {
                        const d = params.data;
                        if (!d || d.length < 4) return '';
                        const timestamp = new Date(d[0]).toLocaleString('ja-JP');
                        const shopName = d[1] || '';
                        const price = d[2] ? d[2].toLocaleString() : 'N/A';
                        return `æ™‚åˆ»: ${timestamp}<br/>åº—èˆ—: ${shopName}<br/>ä¾¡æ ¼: Â¥${price}`;
                    }
                },
                grid3D: {
                    viewControl: {
                        projection: 'orthographic',
                        autoRotate: false,
                        distance: 180
                    },
                    boxWidth: 120,
                    boxHeight: 100,
                    boxDepth: 80
                },
                xAxis3D: {
                    name: 'æ™‚åˆ»',
                    type: 'time',
                    axisLabel: {
                        formatter: function(value) {
                            const d = new Date(value);
                            return `${d.getMonth()+1}/${d.getDate()}\n${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`;
                        },
                        fontSize: 10
                    }
                },
                yAxis3D: {
                    name: 'åº—èˆ—',
                    type: 'category',
                    data: [],
                    axisLabel: {
                        fontSize: 10,
                        interval: 0
                    }
                },
                zAxis3D: {
                    name: 'ä¾¡æ ¼ (JPY)',
                    min: PRICE_VISIBLE_MIN,
                    max: PRICE_VISIBLE_MAX,
                    axisLabel: {
                        formatter: function(value) {
                            return (value / 10000).toFixed(0) + 'ä¸‡';
                        }
                    }
                },
                series: []
            };

            chart.setOption(option);

            Chart3DManager.charts.set(iphoneColor, {
                el: canvas,
                chart: chart,
                data: []
            });
        }

        return Chart3DManager.charts.get(iphoneColor);
    }

    function update3DChartForColor(iphoneColor, title, dataPoints) {
        // dataPoints: [{timestamp, shopId, shopName, shopColor, price}, ...]
        const chartObj = get3DChartForColor(iphoneColor, title);
        if (!chartObj) return;

        // è¿‡æ»¤æœ‰æ•ˆæ•°æ®ç‚¹
        const validData = dataPoints.filter(d => {
            const price = Number(d.price);
            return Number.isFinite(price) && price >= PRICE_VISIBLE_MIN && price <= PRICE_VISIBLE_MAX;
        });

        if (validData.length === 0) return;

        // æå–æ‰€æœ‰å”¯ä¸€çš„åº—é“ºï¼ŒæŒ‰ç…§SHOP_COLOR_RULESçš„é¡ºåºæ’åº
        const shopMap = new Map();
        validData.forEach(d => {
            if (!shopMap.has(d.shopId)) {
                shopMap.set(d.shopId, {
                    id: d.shopId,
                    name: d.shopName,
                    color: d.shopColor,
                    order: getOrderForShop({name: d.shopName, id: d.shopId})
                });
            }
        });
        const shops = Array.from(shopMap.values()).filter(s => s && s.name).sort((a, b) => a.order - b.order);
        const shopNames = shops.map(s => s.name);

        // æŒ‰åº—é“ºåˆ†ç»„æ•°æ®ï¼Œæ¯ä¸ªåº—é“ºä¸€ä¸ªseries
        const seriesByShop = new Map();
        validData.forEach(d => {
            // ç¡®ä¿shopNameå’ŒshopColoræœ‰å€¼
            const safeName = d.shopName || SHOPS_INDEX.get(d.shopId) || `åº—èˆ—#${d.shopId}`;
            const safeColor = d.shopColor || getColorForShop({name: safeName, id: d.shopId}, d.shopId);

            if (!seriesByShop.has(d.shopId)) {
                const shop = shopMap.get(d.shopId);
                seriesByShop.set(d.shopId, {
                    name: safeName,
                    type: 'line3D',  // æ”¹ä¸ºçº¿å‹
                    lineStyle: {
                        width: 2,
                        color: shop?.color || safeColor
                    },
                    data: []
                });
            }
            // æ•°æ®æ ¼å¼: [timestamp, shopName, price]
            seriesByShop.get(d.shopId).data.push([
                d.timestamp,
                safeName,
                d.price
            ]);
        });

        // å¯¹æ¯ä¸ªåº—é“ºçš„æ•°æ®æŒ‰æ—¶é—´æ’åºï¼Œä»¥å½¢æˆæ­£ç¡®çš„çº¿æ¡
        seriesByShop.forEach(series => {
            series.data.sort((a, b) => a[0] - b[0]);
        });

        const series = Array.from(seriesByShop.values()).filter(s => s && s.name);

        // è®¡ç®—ä»·æ ¼èŒƒå›´ä»¥ä¼˜åŒ–Zè½´æ˜¾ç¤º
        const prices = validData.map(d => d.price);
        const minPrice = Math.min(...prices);
        const maxPrice = Math.max(...prices);
        const priceRange = maxPrice - minPrice;

        // æ·»åŠ 10%çš„ä¸Šä¸‹è¾¹è·ä»¥æ›´å¥½åœ°å±•ç¤ºæ³¢åŠ¨
        const padding = priceRange * 0.1;
        const zMin = Math.max(PRICE_VISIBLE_MIN, Math.floor((minPrice - padding) / 1000) * 1000);
        const zMax = Math.min(PRICE_VISIBLE_MAX, Math.ceil((maxPrice + padding) / 1000) * 1000);

        chartObj.data = validData;
        chartObj.chart.setOption({
            yAxis3D: {
                name: 'åº—èˆ—',
                type: 'category',
                data: shopNames,
                axisLabel: {
                    fontSize: 10,
                    interval: 0
                }
            },
            zAxis3D: {
                name: 'ä¾¡æ ¼ (JPY)',
                min: zMin,
                max: zMax,
                axisLabel: {
                    formatter: function(value) {
                        return (value / 10000).toFixed(0) + 'ä¸‡';
                    }
                }
            },
            legend: {
                data: series.map(s => s.name),
                top: 10,
                textStyle: {
                    fontSize: 11
                }
            },
            series: series
        });
    }

    function clear3DCharts() {
        Chart3DManager.charts.forEach(obj => {
            if (obj.chart) obj.chart.dispose();
        });
        Chart3DManager.charts.clear();
        Chart3DManager.dataByColor.clear();
        if (Chart3DManager.host) {
            Chart3DManager.host.innerHTML = '';
        }
    }

    function collect3DDataPoint(shopId, shopName, shopColor, timestamp, price, partNumber, iphoneColor) {
        // æŒ‰iPhoneé¢œè‰²æ”¶é›†æ•°æ®ç‚¹
        const colorKey = iphoneColor || 'ä¸æ˜';
        if (!Chart3DManager.dataByColor.has(colorKey)) {
            Chart3DManager.dataByColor.set(colorKey, []);
        }

        // ç¡®ä¿shopNameå’ŒshopColoræœ‰å€¼ï¼Œä½¿ç”¨å›é€€å€¼
        const safeName = shopName || SHOPS_INDEX.get(shopId) || `åº—èˆ—#${shopId}`;
        const safeColor = shopColor || getColorForShop({name: safeName, id: shopId}, shopId);

        Chart3DManager.dataByColor.get(colorKey).push({
            timestamp,
            shopId,
            shopName: safeName,
            shopColor: safeColor,
            price
        });
    }

    /* ===================== æ°”æ³¡å›¾ç®¡ç† (3å°æ—¶èšåˆ) ===================== */

    // æ°”æ³¡å›¾å®¹å™¨ç®¡ç† - æŒ‰iPhoneé¢œè‰²åˆ†ç»„
    const ChartBubbleManager = {
        charts: new Map(),  // iphoneColor -> {el, chart}
        host: null,
        dataByColor: new Map() // iphoneColor -> [{timestamp, shopId, shopName, shopColor, price}]
    };

    // 3å°æ—¶èšåˆå‡½æ•°ï¼šå°†æ•°æ®æŒ‰3å°æ—¶æ—¶é—´æ¡¶åˆ†ç»„
    function aggregate3HourData(dataPoints) {
        // dataPoints: [{timestamp, shopId, shopName, shopColor, price}, ...]
        // è¿”å›: Map<bucket_timestamp, Map<shopId, {shopName, shopColor, prices: []}>>

        const THREE_HOURS_MS = 3 * 60 * 60 * 1000;
        const buckets = new Map();

        dataPoints.forEach(d => {
            // è®¡ç®—3å°æ—¶æ¡¶çš„èµ·å§‹æ—¶é—´
            const ts = new Date(d.timestamp).getTime();
            const bucketStart = Math.floor(ts / THREE_HOURS_MS) * THREE_HOURS_MS;

            if (!buckets.has(bucketStart)) {
                buckets.set(bucketStart, new Map());
            }

            const shopMap = buckets.get(bucketStart);
            if (!shopMap.has(d.shopId)) {
                shopMap.set(d.shopId, {
                    shopName: d.shopName,
                    shopColor: d.shopColor,
                    prices: []
                });
            }

            shopMap.get(d.shopId).prices.push(d.price);
        });

        // è®¡ç®—æ¯ä¸ªæ¡¶ä¸­æ¯ä¸ªåº—é“ºçš„å¹³å‡ä»·æ ¼
        const aggregated = [];
        buckets.forEach((shopMap, bucketStart) => {
            shopMap.forEach((data, shopId) => {
                const avgPrice = data.prices.reduce((sum, p) => sum + p, 0) / data.prices.length;
                aggregated.push({
                    timestamp: bucketStart,
                    shopId: shopId,
                    shopName: data.shopName,
                    shopColor: data.shopColor,
                    price: avgPrice,
                    count: data.prices.length  // æ•°æ®ç‚¹æ•°é‡
                });
            });
        });

        return aggregated;
    }

    function initBubbleChartHost() {
        if (!ChartBubbleManager.host) {
            ChartBubbleManager.host = document.getElementById('chart_bubble_grid');
        }
        return ChartBubbleManager.host;
    }

    function createBubblePanel(host, iphoneColor, title) {
        const panel = document.createElement('div');
        panel.className = 'chart-bubble-panel';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'chart-bubble-title';
        titleDiv.textContent = title;

        const canvas = document.createElement('div');
        canvas.className = 'chart-bubble-canvas';

        panel.appendChild(titleDiv);
        panel.appendChild(canvas);
        host.appendChild(panel);

        return {panel, canvas};
    }

    function getBubbleChartForColor(iphoneColor, title) {
        if (!ChartBubbleManager.charts.has(iphoneColor)) {
            const host = initBubbleChartHost();
            if (!host) return null;

            const {canvas} = createBubblePanel(host, iphoneColor, title);
            const chart = echarts.init(canvas);

            // åŸºç¡€æ°”æ³¡å›¾é…ç½®
            const option = {
                tooltip: {
                    formatter: function(params) {
                        const d = params.data;
                        if (!d) return '';
                        const timestamp = new Date(d[0]).toLocaleString('ja-JP');
                        const shopName = d[1] || '';
                        const price = d[2] ? d[2].toLocaleString() : 'N/A';
                        const count = d[3] || 1;
                        return `æ™‚åˆ»: ${timestamp}<br/>åº—èˆ—: ${shopName}<br/>å¹³å‡ä¾¡æ ¼: Â¥${price}<br/>ãƒ‡ãƒ¼ã‚¿æ•°: ${count}`;
                    }
                },
                grid: {
                    left: 80,
                    right: 50,
                    top: 80,
                    bottom: 80
                },
                xAxis: {
                    type: 'time',
                    name: 'æ™‚åˆ»',
                    nameLocation: 'middle',
                    nameGap: 30,
                    axisLabel: {
                        formatter: function(value) {
                            const d = new Date(value);
                            return `${d.getMonth()+1}/${d.getDate()} ${d.getHours()}:00`;
                        },
                        rotate: 45
                    }
                },
                yAxis: {
                    type: 'category',
                    name: 'åº—èˆ—',
                    data: [],
                    axisLabel: {
                        interval: 0
                    }
                },
                dataZoom: [
                    {
                        type: 'slider',
                        xAxisIndex: 0,
                        start: 0,
                        end: 100,
                        height: 30,
                        bottom: 10
                    },
                    {
                        type: 'inside',
                        xAxisIndex: 0
                    }
                ],
                legend: {
                    data: [],
                    top: 10
                },
                series: []
            };

            chart.setOption(option);

            ChartBubbleManager.charts.set(iphoneColor, {
                el: canvas,
                chart: chart
            });
        }

        return ChartBubbleManager.charts.get(iphoneColor);
    }

    function updateBubbleChartForColor(iphoneColor, title, dataPoints) {
        // dataPoints: [{timestamp, shopId, shopName, shopColor, price}, ...]
        const chartObj = getBubbleChartForColor(iphoneColor, title);
        if (!chartObj) return;

        // 3å°æ—¶èšåˆ
        const aggregatedData = aggregate3HourData(dataPoints);
        if (aggregatedData.length === 0) return;

        // è®¡ç®—å®é™…ä»·æ ¼èŒƒå›´ï¼ˆç”¨äºæ°”æ³¡å¤§å°æ ‡å‡†åŒ–ï¼‰
        const prices = aggregatedData.map(d => d.price);
        const minPrice = Math.min(...prices);
        const maxPrice = Math.max(...prices);
        const priceRange = maxPrice - minPrice;

        // æå–æ‰€æœ‰å”¯ä¸€çš„åº—é“º
        const shopMap = new Map();
        aggregatedData.forEach(d => {
            if (!shopMap.has(d.shopId)) {
                shopMap.set(d.shopId, {
                    id: d.shopId,
                    name: d.shopName,
                    color: d.shopColor,
                    order: getOrderForShop({name: d.shopName, id: d.shopId})
                });
            }
        });
        const shops = Array.from(shopMap.values()).filter(s => s && s.name).sort((a, b) => a.order - b.order);
        const shopNames = shops.map(s => s.name);

        // æŒ‰åº—é“ºåˆ†ç»„æ•°æ®ï¼Œæ¯ä¸ªåº—é“ºä¸€ä¸ªseries
        const seriesByShop = new Map();
        aggregatedData.forEach(d => {
            const safeName = d.shopName || SHOPS_INDEX.get(d.shopId) || `åº—èˆ—#${d.shopId}`;
            const safeColor = d.shopColor || getColorForShop({name: safeName, id: d.shopId}, d.shopId);

            if (!seriesByShop.has(d.shopId)) {
                const shop = shopMap.get(d.shopId);
                seriesByShop.set(d.shopId, {
                    name: safeName,
                    type: 'scatter',
                    symbolSize: function(data) {
                        // data: [timestamp, shopName, price, count]
                        // æ°”æ³¡å¤§å°åŸºäºä»·æ ¼ï¼ˆä»·æ ¼è¶Šé«˜ï¼Œæ°”æ³¡è¶Šå¤§ï¼‰
                        const price = data[2] || 0;
                        const minSize = 8;
                        const maxSize = 40;

                        // ä½¿ç”¨å®é™…æ•°æ®çš„ä»·æ ¼èŒƒå›´è¿›è¡Œæ ‡å‡†åŒ–
                        if (priceRange === 0) return (minSize + maxSize) / 2; // å¦‚æœä»·æ ¼éƒ½ç›¸åŒï¼Œè¿”å›ä¸­é—´å€¼
                        const normalizedPrice = (price - minPrice) / priceRange;
                        return minSize + normalizedPrice * (maxSize - minSize);
                    },
                    itemStyle: {
                        color: shop?.color || safeColor,
                        opacity: 0.7
                    },
                    data: []
                });
            }

            // æ•°æ®æ ¼å¼: [timestamp, shopName, price, count]
            seriesByShop.get(d.shopId).data.push([
                d.timestamp,
                safeName,
                d.price,
                d.count
            ]);
        });

        const series = Array.from(seriesByShop.values()).filter(s => s && s.name);

        chartObj.chart.setOption({
            yAxis: {
                type: 'category',
                name: 'åº—èˆ—',
                data: shopNames,
                axisLabel: {
                    interval: 0
                }
            },
            legend: {
                data: series.map(s => s.name),
                top: 10
            },
            series: series
        });
    }

    function clearBubbleCharts() {
        ChartBubbleManager.charts.forEach(obj => {
            if (obj.chart) obj.chart.dispose();
        });
        ChartBubbleManager.charts.clear();
        ChartBubbleManager.dataByColor.clear();
        if (ChartBubbleManager.host) {
            ChartBubbleManager.host.innerHTML = '';
        }
    }

    function collectBubbleDataPoint(shopId, shopName, shopColor, timestamp, price, partNumber, iphoneColor) {
        // æŒ‰iPhoneé¢œè‰²æ”¶é›†æ•°æ®ç‚¹ï¼ˆä¸3Då›¾ç›¸åŒçš„æ•°æ®ï¼‰
        const colorKey = iphoneColor || 'ä¸æ˜';
        if (!ChartBubbleManager.dataByColor.has(colorKey)) {
            ChartBubbleManager.dataByColor.set(colorKey, []);
        }

        const safeName = shopName || SHOPS_INDEX.get(shopId) || `åº—èˆ—#${shopId}`;
        const safeColor = shopColor || getColorForShop({name: safeName, id: shopId}, shopId);

        ChartBubbleManager.dataByColor.get(colorKey).push({
            timestamp,
            shopId,
            shopName: safeName,
            shopColor: safeColor,
            price
        });
    }

    function renderBubbleChartsFromCollectedData() {
        // ä»æ”¶é›†çš„æ•°æ®æ¸²æŸ“æ‰€æœ‰æ°”æ³¡å›¾è¡¨ï¼ŒæŒ‰iPhoneé¢œè‰²åˆ†ç»„
        ChartBubbleManager.dataByColor.forEach((dataPoints, iphoneColor) => {
            const title = `${iphoneColor} - ä¾¡æ ¼åˆ†å¸ƒãƒãƒ–ãƒ«ãƒãƒ£ãƒ¼ãƒˆï¼ˆ3æ™‚é–“é›†è¨ˆï¼‰`;
            updateBubbleChartForColor(iphoneColor, title, dataPoints);
        });
    }

    function render3DChartsFromCollectedData() {
        // ä»æ”¶é›†çš„æ•°æ®æ¸²æŸ“æ‰€æœ‰3Då›¾è¡¨ï¼ŒæŒ‰iPhoneé¢œè‰²åˆ†ç»„
        Chart3DManager.dataByColor.forEach((dataPoints, iphoneColor) => {
            const title = `${iphoneColor} - 3Dä¾¡æ ¼åˆ†å¸ƒ`;
            update3DChartForColor(iphoneColor, title, dataPoints);
        });
    }

    /* ===================== End 3Då›¾è¡¨ç®¡ç† ===================== */

    function createPanel(host, titleText, isFeature = false) {
        const panel = document.createElement('div');
        panel.className = 'chart-panel';
        const title = document.createElement('div');
        title.className = 'chart-title';
        title.textContent = titleText || '';
        const canvas = document.createElement('div');
        canvas.className = isFeature ? 'feature-canvas' : 'chart-canvas';
        panel.appendChild(title);
        panel.appendChild(canvas);
        host.appendChild(panel);
        return {panel, canvas};
    }

    function initChartHostsOnce() {
        // ä»·æ ¼åˆ†å›¾å®¹å™¨ï¼š#chart_partsï¼ˆè‹¥ä¸å­˜åœ¨è‡ªåŠ¨æ’åœ¨ #chart ä¹‹åï¼‰
        if (!ChartGrids.hostPrice) {
            let host = document.getElementById('chart_parts');
            if (!host) {
                host = document.createElement('div');
                host.id = 'chart_parts';
                const anchor = document.getElementById('chart') || document.querySelector('.wrap') || document.body;
                anchor.insertAdjacentElement('afterend', host);
            }
            host.innerHTML = '';
            host.classList.add('chart-grid');
            ChartGrids.hostPrice = host;
        }
        // Feature åˆ†å›¾å®¹å™¨ï¼š#chart_featureï¼ˆè‹¥ä¸å­˜åœ¨è‡ªåŠ¨åˆ›å»ºåœ¨ #chart_parts ä¹‹åï¼‰
        if (!ChartGrids.hostFeature) {
            let host = document.getElementById('chart_feature');
            if (!host) {
                host = document.createElement('div');
                host.id = 'chart_feature';
                const anchor = ChartGrids.hostPrice || document.getElementById('chart') || document.body;
                anchor.insertAdjacentElement('afterend', host);
            }
            host.innerHTML = '';
            host.classList.add('chart-grid');
            ChartGrids.hostFeature = host;
        }
    }
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}

    function baseOptionForTimeseries(yName = 'JPY') {
        return {
            animation: false,
            tooltip: {trigger: 'axis', axisPointer: {type: 'cross'}},
            legend: {top: 18, left: 10, itemGap: 14, icon: 'circle'},
            grid: {left: 16, right: 48, top: 45, bottom: 112, containLabel: true},
            xAxis: [{
                type: 'time',
                boundaryGap: false,
                minInterval: ONE_DAY,     // â† é”å®šæ¯å¤©ä¸€æ ¼ï¼ˆä¸‹é™ï¼‰
                maxInterval: ONE_DAY,     // â† é”å®šæ¯å¤©ä¸€æ ¼ï¼ˆä¸Šé™ï¼‰
                axisLabel: {
                    formatter: verticalTickFormatter, lineHeight: 16, margin: 18, hideOverlap: false,   // â† ä¸è‡ªåŠ¨éšè—
                    showMinLabel: true,
                    showMaxLabel: true
                },
                axisTick: {alignWithLabel: true}
            }],
            yAxis: [makeAutoY({
                name: yName,
                position: 'right',
                clamp: (yName === 'JPY') ? [PRICE_VISIBLE_MIN, PRICE_VISIBLE_MAX] : null
            })],
            dataZoom: [
                {type: 'inside', xAxisIndex: [0], filterMode: 'filter'},
                {type: 'slider', xAxisIndex: [0], bottom: 8, height: 14, handleSize: 0, filterMode: 'filter'}
            ],
            series: []
        };
    }
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}
    {#----------------------------------------------------------------------------------------------#}

    function baseOptionForPrice() {
        return baseOptionForTimeseries('JPY');
    }

    function baseOptionForFeature() {
        return baseOptionForTimeseries('Feature');
    }

    function ensureDailyTicksOn(inst, {minMs, maxMs} = {}) {
        const minBound = Number.isFinite(minMs) ? floorDay(minMs) : floorDay(SELECTED_START_MS);
        const maxBound = Number.isFinite(maxMs) ? ceilDay(maxMs) : ceilDay(SELECTED_END_MS);
        inst.setOption({
            xAxis: [{
                type: 'time',
                boundaryGap: false,
                minInterval: ONE_DAY,
                maxInterval: ONE_DAY,
                min: Number.isFinite(minBound) ? minBound : null,
                max: Number.isFinite(maxBound) ? maxBound : null,
                axisLabel: {
                    formatter: verticalTickFormatter, lineHeight: 16, margin: 18, hideOverlap: false,
                    showMinLabel: true,
                    showMaxLabel: true
                },
                axisTick: {alignWithLabel: true}
            }]
        }, {notMerge: false, lazyUpdate: true});
    }

    function ensureDailyTicksAll() {
        ChartGrids.price.forEach(m => ensureDailyTicksOn(m.chart));
        ChartGrids.feature.forEach(m => ensureDailyTicksOn(m.chart));
    }

    function createPanelAndInitChart(host, titleText, isFeature = false) {
        const {panel, canvas} = createPanel(host, titleText, isFeature);
        const inst = echarts.init(canvas);

        const opt = isFeature ? baseOptionForFeature() : baseOptionForPrice();
        inst.setOption(opt, true);

        // å›ºå®šæ¯å¤©æ—¥æœŸéƒ½æ˜¾ç¤ºï¼ˆä½ å·²æœ‰è¯¥å‡½æ•°ï¼‰
        ensureDailyTicksOn(inst);

        // â˜… æ–°å¢ï¼šåˆå§‹åŒ–åç«‹åˆ»é“ºä¸Šè¥ä¸šæ—¶æ®µèƒŒæ™¯ï¼ˆè‹¥æ—¶é—´èŒƒå›´å·²é€‰æ‹©ï¼‰
        if (Number.isFinite(SELECTED_START_MS) && Number.isFinite(SELECTED_END_MS)) {
            applyWorkHoursOverlayOn(inst, SELECTED_START_MS, SELECTED_END_MS);
        }

        return {el: panel, chart: inst};
    }


    function buildBusinessHoursMarkArea10to19(startMs, endMs) {
        const oneDay = 24 * 3600 * 1000;
        const data = [];
        let d0 = new Date(startMs);
        d0.setHours(0, 0, 0, 0);
        for (let t = d0.valueOf(); t <= endMs + oneDay; t += oneDay) {
            const s10 = new Date(t);
            s10.setHours(10, 0, 0, 0);
            const e19 = new Date(t);
            e19.setHours(19, 0, 0, 0);
            const left = Math.max(s10.valueOf(), startMs);
            const right = Math.min(e19.valueOf(), endMs);
            if (left < right) data.push([{xAxis: left}, {xAxis: right}]);
        }
        return {silent: true, itemStyle: {color: '#fffef8', opacity: 0.35}, data};
    }

    function applyWorkHoursOverlayOn(inst, startMs, endMs) {
        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) return;
        inst.setOption({
            series: [{
                id: '__workhours__',
                type: 'line',
                data: [],
                markArea: buildBusinessHoursMarkArea10to19(startMs, endMs),
                silent: true,
                z: -10
            }]
        }, {notMerge: false, lazyUpdate: true});
    }

    function applyWorkHoursOverlayAll(startMs, endMs) {
        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) return;
        const patch = {
            series: [{
                id: '__workhours__',
                type: 'line',
                data: [],
                markArea: buildBusinessHoursMarkArea10to19(startMs, endMs),
                silent: true,
                z: -10
            }]
        };
        // ä¸»å›¾ï¼ˆæ—§æŸ¥è¯¢/æ±‡æ€»ï¼‰
        if (typeof chart !== 'undefined' && chart) {
            chart.setOption(patch, {notMerge: false, lazyUpdate: true});
        }
        // æ–°çš„å¤šåˆ†å›¾æ …æ ¼
        ChartGrids?.price?.forEach?.(m => m.chart.setOption(patch, {notMerge: false, lazyUpdate: true}));
        ChartGrids?.feature?.forEach?.(m => m.chart.setOption(patch, {notMerge: false, lazyUpdate: true}));
    }


    /**
     * è¤‡æ•°ç³»åˆ—ã‚’æ™‚é–“çª“å£ã§é›†ç´„ã—ã¦å¹³å‡å€¤ã‚’è¨ˆç®—
     *
     * æ™‚é–“æˆ³ã‚’ AGG_TIME_WINDOW_MS ã§å‰²ã£ã¦åˆ‡ã‚Šä¸‹ã’ã‚‹ã“ã¨ã§ã€
     * åŒã˜æ™‚é–“çª—å£å†…ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’1ã¤ã®ãƒã‚±ãƒƒãƒˆã¨ã—ã¦é›†ç´„ã—ã¾ã™ã€‚
     *
     * Before (å•é¡Œ):
     * - æ™‚é–“æˆ³ãŒå®Œå…¨ã«ä¸€è‡´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®ã¿é›†ç´„
     * - æ™‚é–“æˆ³ãŒå°‘ã—ãšã‚Œã¦ã„ã‚‹ã¨ãƒãƒ©ãƒãƒ©ã«ãªã‚Šã€æ³¢å‹•ãŒæ¿€ã—ã„
     *
     * After (æ”¹å–„):
     * - AGG_TIME_WINDOW_MSï¼ˆä¾‹ï¼š5åˆ†ï¼‰ã®çª—å£å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’é›†ç´„
     * - ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªå¹³å‡å€¤æ›²ç·šã‚’ç”Ÿæˆ
     *
     * @param {Array<Array>} seriesList - è¤‡æ•°ç³»åˆ—ã®ãƒ‡ãƒ¼ã‚¿é…åˆ—
     * @returns {Array<[number, number]>} é›†ç´„å¾Œã® [æ™‚é–“æˆ³, å¹³å‡å€¤] é…åˆ—
     * @example
     * // 5åˆ†çª—å£ã§é›†ç´„
     * const avgSeries = mergeSeriesAverage([series1, series2, series3]);
     */
    function mergeSeriesAverage(seriesList) {
        const acc = new Map(); // bucket_ts -> {sum, count}
        for (const series of seriesList) {
            for (const item of series) {
                const v = Array.isArray(item) ? item : item?.value;
                const ts = Array.isArray(v) ? v[0] : NaN;
                const y = _yOf(item);
                if (!Number.isFinite(ts) || !Number.isFinite(y)) continue;

                // â˜… æ™‚é–“çª—å£ã§ãƒã‚±ãƒƒãƒˆåŒ–: æ™‚é–“æˆ³ã‚’çª—å£ã‚µã‚¤ã‚ºã§åˆ‡ã‚Šä¸‹ã’
                const bucketTs = Math.floor(ts / AGG_TIME_WINDOW_MS) * AGG_TIME_WINDOW_MS;

                const cur = acc.get(bucketTs) || {sum: 0, count: 0};
                cur.sum += y;
                cur.count += 1;
                acc.set(bucketTs, cur);
            }
        }
        return Array.from(acc.entries())
            .map(([t, {sum, count}]) => [t, sum / count])
            .sort((a, b) => a[0] - b[0]);
    }

    // æŠŠâ€œå„åº—å‡å€¼æ›²çº¿â€ç»˜åˆ°ä¸»å›¾ï¼›åªä¿ç•™è¿™äº›æ±‡æ€»ç³»åˆ—
    function renderAggregateOnMain(aggByShopMap, startMs, endMs) {
        const series = [];
        let idx = 0;
        for (const [sid, list] of aggByShopMap.entries()) {
            const sname = SHOPS_INDEX.get(sid) || `#${sid}`;
            const color = getColorForShop({name: sname, id: sid}, idx++);
            const data = mergeSeriesAverage(list);
            series.push({
                id: `avg:s:${sid}`,
                name: `${sname}ï¼ˆå¹³å‡ï¼‰`,
                type: 'line',
                showSymbol: false,
                smooth: 0.15,
                xAxisIndex: 0, yAxisIndex: 0,
                emphasis: {focus: 'series'},
                lineStyle: {width: 2, color},
                itemStyle: {color},
                data
            });
        }
        chart.clear();
        chart.setOption({
            ...baseOption,
            legend: {data: series.map(s => s.name)},
            series
        }, true);
        ensureDailyTicks();                       // åŠ â€œæ—¥ç²’åº¦ + ç«–æ’â€åˆ»åº¦
        applyWorkHoursOverlayOn(startMs, endMs);   // è¥ä¸šæ—¶æ®µåº•è‰²
        updateStatsChart();                       // ç»Ÿè®¡å›¾åŒæ­¥
        adjustGridTopForLegend(chart);
    }


    /** â€”â€” å·¥å…·ï¼šæŠŠ part number è½¬æˆâ€œäººç±»å‹å¥½â€åç§° â€”â€” */
    function humanNameOfPart(partNumber, {withPn = true} = {}) {
        const pn = String(partNumber || '').trim();
        // ç»Ÿä¸€ä½¿ç”¨å½“å‰è„šæœ¬å·²ç»ç»´æŠ¤çš„ç¼“å­˜ï¼ˆloadIphones / mountAllScopeSelectors ä¼šå¡«å……ï¼‰
        const info = IPHONE_INFO_BY_PART.get(pn);
        if (!info) return pn;             // æ‰¾ä¸åˆ°å°±å›é€€æ˜¾ç¤º PN
        // å¤ç”¨å·²æœ‰çš„æ‹¼è£…é€»è¾‘ï¼Œä¿è¯å±•ç¤ºä¸€è‡´æ€§
        const label = iphoneHumanLabelByPart(pn); // ä¾‹å¦‚ "iPhone 15 Pro 256GB ç™½"
        return withPn ? `${label}ï½œ${pn}` : label;
    }

    function titleForPrice(partNumber) {
        return `ä¾¡æ ¼æ›²ç·š ï½œ ${humanNameOfPart(partNumber)}`;
    }

    function titleForFeature(partNumber) {
        return `FeatureSnapshot ï½œ ${humanNameOfPart(partNumber)}`;
    }


    function ensurePriceChartForPart(partNumber) {
        initChartHostsOnce();
        if (!ChartGrids.price.has(partNumber)) {
            // æ ‡é¢˜æ”¹ä¸ºâ€œäººç±»å‹å¥½æ–‡æ¡ˆâ€
            const m = createPanelAndInitChart(ChartGrids.hostPrice, titleForPrice(partNumber), false);
            // ç»Ÿä¸€åŠ â€œæ—¥ç²’åº¦ç«–æ’æ—¥æœŸè½´â€
            ensureDailyTicksOn(m.chart);
            ChartGrids.price.set(partNumber, m);
        }
        return ChartGrids.price.get(partNumber).chart;
    }


    function ensureFeatureChartForPart(partNumber) {
        initChartHostsOnce();
        if (!ChartGrids.feature.has(partNumber)) {
            // æ ‡é¢˜æ”¹ä¸ºâ€œäººç±»å‹å¥½æ–‡æ¡ˆâ€
            const m = createPanelAndInitChart(ChartGrids.hostFeature, titleForFeature(partNumber), true);
            // ç»Ÿä¸€åŠ â€œæ—¥ç²’åº¦ç«–æ’æ—¥æœŸè½´â€
            ensureDailyTicksOn(m.chart);
            ChartGrids.feature.set(partNumber, m);
        }
        return ChartGrids.feature.get(partNumber).chart;
    }

    function disposeAllPartCharts() {
        ChartGrids.price.forEach(m => {
            try {
                m.chart.dispose();
            } catch {
            }
        });
        ChartGrids.feature.forEach(m => {
            try {
                m.chart.dispose();
            } catch {
            }
        });
        ChartGrids.price.clear();
        ChartGrids.feature.clear();
        if (ChartGrids.hostPrice) ChartGrids.hostPrice.innerHTML = '';
        if (ChartGrids.hostFeature) ChartGrids.hostFeature.innerHTML = '';
    }

    /* â€”â€” ä¸»å›¾ï¼ˆä»…ç”¨äº A æ—§æŸ¥è¯¢ï¼‰ â€”â€” */
    const baseOption = baseOptionForPrice();
    let CHART_MAIN = null;

    function getMainChart() {
        if (!CHART_MAIN) {
            const el = document.getElementById('chart');
            if (!el) {
                console.warn('#chart not found');
                return null;
            }
            CHART_MAIN = echarts.init(el);
            CHART_MAIN.setOption(baseOption, true);
            CHART_MAIN.setOption(Object.assign({}, baseOption, {
                grid: Object.assign({}, baseOption.grid, {bottom: 40}) // æ¨ªè½´ç•™ç™½
            }), true);
            ensureDailyTicksOn(CHART_MAIN);
            window.addEventListener('resize', () => {
  if (!CHART_MAIN) return;
  CHART_MAIN.resize();
  adjustGridTopForLegend(CHART_MAIN);
});

        }
        return CHART_MAIN;
    }

    const chart = getMainChart();

    /* â€”â€” æ–°æ—§ä¸¤å¥—"å¢æ”¹ç³»åˆ—" â€”â€” */
    // ä¸»å›¾ç”¨ï¼ˆAï¼‰
    function addOrUpdateSeries(id, name, color, data) {
        const inst = chart;
        if (!inst) return;
        const opt = inst.getOption() || {};
        const cur = (opt.series || []).filter(s => s.id !== '__workhours__');
        const idx = cur.findIndex(s => s.id === id);

        // ç¡®ä¿nameæœ‰å€¼
        const safeName = name || `Series#${id}`;

        const base = {
            id, name: safeName, type: 'line', showSymbol: false, smooth: 0.15,
            xAxisIndex: 0, yAxisIndex: 0,
            emphasis: {focus: 'series'},
            lineStyle: {width: 2, color},
            itemStyle: {color},
            data
        };
        if (idx >= 0) cur[idx] = {
            ...cur[idx],
            name: safeName,
            data,
            lineStyle: {...(cur[idx].lineStyle || {}), width: 2, color},
            itemStyle: {color}
        };
        else cur.push(base);

        // è¿‡æ»¤æ‰nameä¸ºundefinedçš„å…ƒç´ 
        const validCur = cur.filter(s => s && s.name);
        inst.setOption({series: validCur, legend: {data: validCur.map(s => s.name)}}, {notMerge: false, lazyUpdate: true});
        adjustGridTopForLegend(inst);
    }

    // å–å•æŒ‡æ ‡
    async function fetchFeaturePointsSimple(scope, name, startUtc, endUtc) {
        const u = new URL(FEATURE_SERIES_API.replace(/\/+$/, ''), location.origin);
        u.searchParams.set('scope', scope);
        applyFeatureMetricParam(u, name);  // mean/std â†’ name=ï¼Œå…¶ä½™ â†’ version=
        if (startUtc) u.searchParams.set('bucket__gte', startUtc);
        if (endUtc) u.searchParams.set('bucket__lte', endUtc);
        const headers = {'Accept': 'application/json'};
        const token = localStorage.getItem('iphone:token');
        if (token) headers['Authorization'] = `Bearer ${token}`;
        const r = await fetch(u.toString(), {headers});
        if (!r.ok) throw new Error(`features/points ${r.status}`);
        const arr = await r.json();
        return Array.isArray(arr) ? arr : [];
    }

    // åˆ†å›¾ç”¨ï¼ˆB/C/D/Eï¼‰
    function addOrUpdateSeriesForPart(part, id, name, color, data) {
        const inst = ensurePriceChartForPart(part);
        const opt = inst.getOption() || {};
        const arr = (opt.series || []).slice();
        const idx = arr.findIndex(s => s.id === id);

        // ç¡®ä¿nameæœ‰å€¼
        const safeName = name || `Series#${id}`;

        const base = {
            id, name: safeName,
            type: 'line', showSymbol: false, smooth: 0.15,
            xAxisIndex: 0, yAxisIndex: 0,
            emphasis: {focus: 'series'},
            lineStyle: {width: 2, color},
            itemStyle: {color},
            data
        };
        if (idx >= 0) {
            arr[idx] = {
                ...arr[idx], name: safeName, data, xAxisIndex: 0, yAxisIndex: 0,
                lineStyle: {...(arr[idx].lineStyle || {}), width: 2, color}, itemStyle: {color}
            };
        } else {
            arr.push(base);
        }

        // è¿‡æ»¤æ‰nameä¸ºundefinedçš„å…ƒç´ 
        const validArr = arr.filter(s => s && s.name);
        inst.setOption({series: validArr, legend: {data: validArr.map(s => s.name)}}, {notMerge: false, lazyUpdate: true});
    adjustGridTopForLegend(inst);
    }

    /* ===================== 3) æ•°æ®åŠ è½½ ===================== */

    async function loadShops() {
        const box = $('shops');
        if (box) box.innerHTML = '';
        SHOPS_INDEX.clear();
        try {
            const resp = await fetch(ENDPOINT_SHOPS);
            const payload = await resp.json();
            const items = Array.isArray(payload) ? payload
                : Array.isArray(payload?.results) ? payload.results
                    : Array.isArray(payload?.items) ? payload.items : [];
            const normalized = [];
            for (const s of items) {
                const sid = Number(s?.id ?? s?.shop_id ?? s?.pk);
                if (!Number.isFinite(sid)) continue;
                const name = s?.name ?? s?.shop_name ?? s?.display_name ?? String(sid);
                const order = getOrderForShop({name, id: sid});
                const color = getColorForShop({name, id: sid}, normalized.length);
                normalized.push({id: sid, name, order, color});
                SHOPS_INDEX.set(sid, name);
            }
            normalized.sort((a, b) => (a.order - b.order) || a.name.localeCompare(b.name, 'ja'));
            if (box) {
                for (const s of normalized) {
                    const label = document.createElement('label');
                    label.title = s.name;
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.value = String(s.id);
                    input.dataset.name = s.name;
                    input.dataset.shopId = String(s.id);
                    const span = document.createElement('span');
                    span.textContent = s.name;
                    span.style.color = s.color;
                    label.appendChild(input);
                    label.appendChild(span);
                    box.appendChild(label);
                }
            }
        } catch (e) {
            console.warn('loadShops failed', e);
        }
    }

    async function loadIphones() {
        const dl = $('iphone-list');
        if (dl) dl.innerHTML = '';
        IPHONE_ID_BY_PART.clear();
        try {
            const resp = await fetch(ENDPOINT_IPHONES);
            const items = await resp.json();
            for (const i of items) {
                IPHONE_INFO_BY_PART.set(String(i.part_number), i);
                const text = `${i.part_number} ï½œ ${i.model_name} ${i.capacity_gb}GB ï½œ ${i.color}`;
                if (dl) {
                    const opt = document.createElement('option');
                    opt.value = i.part_number;
                    opt.label = text;
                    dl.appendChild(opt);
                }
                if (i.id != null && i.part_number) IPHONE_ID_BY_PART.set(String(i.part_number), Number(i.id));
            }
        } catch (e) {
            console.warn('loadIphones failed', e);
        }
    }

    function buildURL(base, startIsoJST, endIsoJST, shopId, partNumber) {
        const sid = Number(shopId);
        if (!Number.isFinite(sid)) throw new Error('Invalid shop id');
        if (!startIsoJST || !endIsoJST) throw new Error('Invalid time range');
        const u = new URL(base, location.origin);
        u.searchParams.set("start", startIsoJST);
        u.searchParams.set("end", endIsoJST);
        u.searchParams.set("shop", String(sid));
        u.searchParams.set("iphone__part_number", String(partNumber));
        return u.toString();
    }

    async function fetchOneShopSeries(base, startIsoJST, endIsoJST, shopId, shopName, partNumber) {
        const url = buildURL(base, startIsoJST, endIsoJST, shopId, partNumber);
        const headers = {"Accept": "application/json"};
        const token = localStorage.getItem('iphone:token');
        if (token) headers["Authorization"] = `Bearer ${token}`;
        const resp = await fetch(url, {headers});
        if (!resp.ok) {
            const txt = await resp.text().catch(() => '');
            throw new Error(`HTTP ${resp.status} ${resp.statusText} | ${txt.slice(0, 200)}`);
        }
        const payload = await resp.json();
        const raw = Array.isArray(payload) ? payload
            : Array.isArray(payload?.results) ? payload.results
                : Array.isArray(payload?.items) ? payload.items : [];
        // å­—æ®µå…œåº•
        const pick = (r, kList) => kList.find(k => k in r) ?? kList[0];
        const tKey = raw[0] ? pick(raw[0], ["Timestamp_Time", "timestamp_time", "timestamp", "ts", "t"]) : "Timestamp_Time";
        const pKey = raw[0] ? pick(raw[0], ["New_Product_Price", "new_product_price", "price", "value"]) : "New_Product_Price";
        const pnKey = raw[0] ? pick(raw[0], ["iphone", "iphone__part_number", "part_number"]) : "iphone";
        const rows = raw.filter(r => !r[pnKey] || r[pnKey] === partNumber);
        const data = rows
            .map(r => [new Date(r[tKey]).valueOf(), Number(r[pKey])])
            .filter(([t, y]) =>
                Number.isFinite(t) &&
                Number.isFinite(y) &&
                y >= PRICE_VISIBLE_MIN &&
                y <= PRICE_VISIBLE_MAX
            )
            .sort((a, b) => a[0] - b[0]);
        return {name: shopName, data};
    }

    function appendShadowToNowIfNeeded(seriesData) {
        if (!seriesData.length) return seriesData;
        const last = seriesData[seriesData.length - 1];
        const nowMin = nearestPastMinuteMs();
        const lastT = Array.isArray(last) ? last[0] : (last?.value?.[0] ?? NaN);
        const lastY = Array.isArray(last) ? last[1] : (last?.value?.[1] ?? NaN);
        if (Number.isFinite(lastT) && lastT < nowMin && Number.isFinite(lastY)) {
            seriesData.push({
                value: [nowMin, lastY],
                symbol: 'emptyCircle',
                symbolSize: 6,
                shadow: true,
                src_ts: lastT
            });
        }
        return seriesData;
    }

    /* ===================== 4) Scopesï¼šcohort / profile / iphone é€‰é¡¹ ===================== */


    async function loadScopesOnce() {
        if (_SCOPES_CACHE) return _SCOPES_CACHE;
        const resp = await fetch(ENDPOINT_SCOPES, {headers: {"Accept": "application/json"}});
        if (!resp.ok) throw new Error(`Scopes HTTP ${resp.status}`);
        _SCOPES_CACHE = await resp.json();
        return _SCOPES_CACHE || {};
    }

    function extractProfilesFromScopes(scopes) {
        const profs = arrFirst(scopes, ['shop_profiles', 'profiles', 'shopGroups', 'shop_groups']);
        return profs.map(p => {
            const itemsRaw = arrFirst(p, ['items', 'members', 'shops', 'shop_members']);
            const items = itemsRaw.map(it => ({
                shop_id: Number(it.shop_id ?? it.id ?? it.pk),
                shop_name: it.shop_name ?? it.name ?? it.display_name ?? String(it.shop_id ?? it.id ?? ''),
                display_index: Number(it.display_index ?? it.index ?? it.order ?? 999)
            })).filter(x => Number.isFinite(x.shop_id));
            return {
                id: Number(p.id ?? p.profile_id ?? p.pk),
                slug: p.slug ?? String(p.id ?? ''),
                title: p.title || p.label || p.slug || `Profile #${p.id}`,
                label: p.label || p.title || p.slug, items
            };
        }).filter(x => Number.isFinite(x.id));
    }

    function extractCohortsFromScopes(scopes) {
        const raws = arrFirst(scopes, ['cohorts', 'iphone_cohorts', 'groups', 'iphone_groups']);
        return raws.map(c => {
            const memRaw = arrFirst(c, ['members', 'items', 'iphones', 'iphone_members', 'phones']);
            const members = memRaw.map(m => {
                const capRaw = m.capacity_gb ?? m.capacity ?? m.storage_gb ?? m.storage;
                const cap = (typeof capRaw === 'string') ? Number(capRaw.replace(/[^\d]/g, '')) : Number(capRaw);
                return {
                    iphone_id: Number(m.iphone_id ?? m.id ?? m.pk),
                    part_number: m.part_number ?? m.pn ?? m.part ?? m.sku,
                    model_name: m.model_name ?? m.model ?? m.name ?? '',
                    capacity_gb: Number.isFinite(cap) ? cap : undefined,
                    color: m.color ?? m.colour ?? m.color_name ?? ''
                };
            }).filter(x => (Number.isFinite(x.iphone_id) || x.part_number));
            return {
                id: Number(c.id ?? c.cohort_id ?? c.pk),
                slug: c.slug ?? String(c.id ?? ''),
                title: c.title || c.label || c.slug || `Cohort #${c.id}`,
                label: c.label || c.title || c.slug, members
            };
        }).filter(x => Number.isFinite(x.id));
    }

    function extractUniqueIphonesFromScopes(scopes) {
        const cohorts = extractCohortsFromScopes(scopes);
        const seen = new Map();
        for (const coh of cohorts) for (const m of coh.members) {
            const pn = m.part_number;
            if (!pn) continue;
            if (!seen.has(pn)) {
                seen.set(pn, {
                    iphone_id: Number(m.iphone_id), part_number: pn,
                    model_name: m.model_name, capacity_gb: m.capacity_gb, color: m.color,
                    label: `${m.model_name} ${m.capacity_gb ? m.capacity_gb + 'GB' : ''} ï½œ ${pn} ï½œ ${m.color || ''}`
                });
            }
        }
        return Array.from(seen.values()).sort((a, b) => (a.model_name || '').localeCompare(b.model_name || '', 'ja') || String(a.part_number).localeCompare(b.part_number));
    }

    /* datalist å°æŒ‚è½½ï¼ˆå•é€‰ï¼‰ */
    function mountDatalistSingle({
                                     inputId, listId, hintId, hiddenId, swatchId, items,
                                     valueBuilder, colorResolver, nameResolver, parseByPattern, labelBuilder
                                 }) {
        const inputEl = $(inputId), listEl = $(listId), hintEl = $(hintId), hiddenEl = $(hiddenId);
        const swatchEl = swatchId ? $(swatchId) : null;
        if (!inputEl || !listEl) return;

        const TEXT_TO_ITEM = new Map(), ID_TO_ITEM = new Map();
        listEl.innerHTML = '';
        for (const item of items) {
            const v = valueBuilder(item);
            const opt = document.createElement('option');
            opt.value = v;
            if (typeof labelBuilder === 'function') opt.label = labelBuilder(item);
            listEl.appendChild(opt);
            TEXT_TO_ITEM.set(v, item);
            const anyId = Number(item.id ?? item.iphone_id ?? item.shop_id ?? item.profile_id ?? item.cohort_id);
            if (Number.isFinite(anyId)) ID_TO_ITEM.set(anyId, item);
        }
        if (hintEl) hintEl.textContent = 'å€™è£œã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„';

        function resolve(raw) {
            if (!raw) return null;
            if (TEXT_TO_ITEM.has(raw)) return TEXT_TO_ITEM.get(raw);
            if (typeof parseByPattern === 'function') {
                const id = parseByPattern(raw);
                if (id != null && ID_TO_ITEM.has(id)) return ID_TO_ITEM.get(id);
            }
            const name = (raw || '').replace(/\s*\(#\d+\)\s*$/, '').trim();
            const candidates = items.filter(it => (nameResolver?.(it) || '') === name);
            if (candidates.length === 1) return candidates[0];
            return null;
        }

        function apply(item) {
            if (hiddenEl) hiddenEl.value = item ? String(item.id ?? item.iphone_id ?? item.shop_id ?? item.profile_id ?? item.cohort_id) : '';
            if (swatchEl) {
                const col = item ? (colorResolver?.(item) || '#999') : '#999';
                swatchEl.style.background = col;
                swatchEl.title = item ? `${nameResolver?.(item) || ''} ${col}` : '';
            }
            if (hintEl) hintEl.textContent = item ? `${nameResolver?.(item) || ''} ã‚’é¸æŠã—ã¾ã—ãŸ` : 'å€™è£œã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„';
        }

        inputEl.addEventListener('input', () => apply(null));
        inputEl.addEventListener('change', () => apply(resolve(inputEl.value.trim())));
        inputEl.addEventListener('blur', () => apply(resolve(inputEl.value.trim())));
    }

    /* å°† scopes æ•°æ®è£…å…¥ A/B/C/D/E çš„ datalist */
    async function mountAllScopeSelectors() {
        const scopes = await loadScopesOnce();

        const shops = (() => {
            // ä» scopes å½’å¹¶å”¯ä¸€é—¨åº—ï¼Œå¹¶æŒ‰å›ºå®šé¡ºåºæ’åº
            const profs = arrFirst(scopes, ['shop_profiles', 'profiles', 'shopGroups', 'shop_groups']);
            const seen = new Map();
            for (const p of profs) {
                const mems = arrFirst(p, ['items', 'members', 'shops', 'shop_members']);
                for (const it of mems) {
                    const sid = Number(it.shop_id ?? it.id ?? it.pk);
                    const sname = it.shop_name ?? it.name ?? it.display_name ?? String(sid);
                    if (!Number.isFinite(sid)) continue;
                    if (!seen.has(sid)) {
                        const order = getOrderForShop({name: sname, id: sid});
                        const color = getColorForShop({name: sname, id: sid}, seen.size);
                        seen.set(sid, {id: sid, name: sname, order, color});
                    }
                }
            }
            return Array.from(seen.values()).sort((a, b) => (a.order - b.order) || a.name.localeCompare(b.name, 'ja'));
        })();

        SHOP_PROFILES = extractProfilesFromScopes(scopes);
        COHORTS = extractCohortsFromScopes(scopes);
        PROFILE_BY_ID = new Map(SHOP_PROFILES.map(p => [Number(p.id), p]));
        COHORT_BY_ID = new Map(COHORTS.map(c => [Number(c.id), c]));
        const iphones = extractUniqueIphonesFromScopes(scopes).map(i => ({...i, id: i.iphone_id}));
        iphones.forEach(i => IPHONE_INFO_BY_PART.set(String(i.part_number), i));
        const iphoneOptionLabel = (i) => {
            const pn = i.part_number || '';
            const model = i.model_name || '';
            const capStr = i.capacity_gb ? `${i.capacity_gb}GB` : '';
            const color = i.color || '';
            return `${pn} ï½œ ${model} ${capStr} ï½œ ${color}`.trim();
        };

        // A) åº—é“º/Part
        mountDatalistSingle({
            inputId: 'sA_shop', listId: 'sA_shop_list', hintId: 'sA_shop_hint',
            hiddenId: 'sA_shop_id', swatchId: 'sA_shop_swatch',
            items: shops,
            valueBuilder: s => `${s.name} (#${s.id})`,
            nameResolver: s => s.name,
            colorResolver: s => s.color,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });
        mountDatalistSingle({
            inputId: 'sA_part', listId: 'sA_part_list', hintId: 'sA_part_hint',
            hiddenId: 'sA_iphone_id',
            items: iphones,
            valueBuilder: i => i.part_number,
            labelBuilder: iphoneOptionLabel,
            nameResolver: i => i.part_number
        });

        // B) Cohort
        mountDatalistSingle({
            inputId: 'sB_cohort', listId: 'sB_cohort_list', hintId: 'sB_cohort_hint',
            hiddenId: 'sB_cohort_id',
            items: COHORTS,
            valueBuilder: c => `${c.title} (#${c.id})`,
            nameResolver: c => c.title,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });

        // C) Profile + Part
        mountDatalistSingle({
            inputId: 'sC_profile', listId: 'sC_profile_list', hintId: 'sC_profile_hint',
            hiddenId: 'sC_profile_id', swatchId: 'sC_profile_swatch',
            items: SHOP_PROFILES.map(p => {
                const its = (Array.isArray(p.items) ? p.items.slice() : []).sort((a, b) => (a.display_index || 999) - (b.display_index || 999));
                let rep = '#999';
                if (its.length) {
                    const sid = Number(its[0].shop_id);
                    const sname = its[0].shop_name || String(sid);
                    rep = getColorForShop({id: sid, name: sname}, 0);
                }
                return {...p, _color: rep};
            }),
            valueBuilder: p => `${p.title} (#${p.id})`,
            nameResolver: p => p.title, colorResolver: p => p._color,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });
        mountDatalistSingle({
            inputId: 'sC_part', listId: 'sC_part_list', hintId: 'sC_part_hint',
            hiddenId: 'sC_iphone_id',
            items: iphones,
            valueBuilder: i => i.part_number,
            labelBuilder: iphoneOptionLabel,
            nameResolver: i => i.part_number
        });

        // D) å•åº— + Cohort
        mountDatalistSingle({
            inputId: 'sD_shop', listId: 'sD_shop_list', hintId: 'sD_shop_hint',
            hiddenId: 'sD_shop_id', swatchId: 'sD_shop_swatch',
            items: shops,
            valueBuilder: s => `${s.name} (#${s.id})`,
            nameResolver: s => s.name, colorResolver: s => s.color,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });
        mountDatalistSingle({
            inputId: 'sD_cohort', listId: 'sD_cohort_list', hintId: 'sD_cohort_hint',
            hiddenId: 'sD_cohort_id',
            items: COHORTS,
            valueBuilder: c => `${c.title} (#${c.id})`,
            nameResolver: c => c.title,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });

        // E) Profile + Cohort
        mountDatalistSingle({
            inputId: 'sE_profile', listId: 'sE_profile_list', hintId: 'sE_profile_hint',
            hiddenId: 'sE_profile_id', swatchId: 'sE_profile_swatch',
            items: SHOP_PROFILES.map(p => {
                const its = (Array.isArray(p.items) ? p.items.slice() : []).sort((a, b) => (a.display_index || 999) - (b.display_index || 999));
                let rep = '#999';
                if (its.length) {
                    const sid = Number(its[0].shop_id);
                    const sname = its[0].shop_name || String(sid);
                    rep = getColorForShop({id: sid, name: sname}, 0);
                }
                return {...p, _color: rep};
            }),
            valueBuilder: p => `${p.title} (#${p.id})`,
            nameResolver: p => p.title, colorResolver: p => p._color,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });
        mountDatalistSingle({
            inputId: 'sE_cohort', listId: 'sE_cohort_list', hintId: 'sE_cohort_hint',
            hiddenId: 'sE_cohort_id',
            items: COHORTS,
            valueBuilder: c => `${c.title} (#${c.id})`,
            nameResolver: c => c.title,
            parseByPattern: raw => {
                const m = raw.match(/\(#\s*(\d+)\s*\)$/);
                return m ? Number(m[1]) : null;
            }
        });
    }

    /* ===================== 5) FeatureSnapshot ===================== */

    const FEATURE_NAMES_DEFAULT = ['mean', 'std', "wma60m", "wma120m", 'wma900m', 'wma1800m', "ema_hl30m", "ema_hl60m", "sma75m"]; // é»˜è®¤æŠ“ä¸¤æ¡æŒ‡æ ‡

    function toUtcZ(isoStr) {
        return new Date(isoStr).toISOString().replace('.000Z', 'Z');
    }

    function buildFeatureScope({shopId = null, profileSlug = null, iphoneId = null}) {
        const parts = [];
        if (profileSlug) parts.push(`shopcohort:${profileSlug}`); else if (shopId != null) parts.push(`shop:${shopId}`);
        if (iphoneId != null) parts.push(`iphone:${iphoneId}`);
        return parts.join('|');
    }

    async function fetchFeatureSeries({scope, name, startIso, endIso}) {
        const u = new URL(FEATURE_SERIES_API, location.origin);
        u.searchParams.set('scope', scope);
        applyFeatureMetricParam(u, name);  // mean/std èµ° name=ï¼Œå…¶å®ƒèµ° version=
        u.searchParams.set('bucket__gte', toUtcZ(startIso));
        u.searchParams.set('bucket__lte', toUtcZ(endIso));
        const headers = {"Accept": "application/json"};
        const token = localStorage.getItem('iphone:token');
        if (token) headers["Authorization"] = `Bearer ${token}`;
        const resp = await fetch(u.toString(), {headers});
        if (!resp.ok) throw new Error(`Feature HTTP ${resp.status}`);
        const arr = await resp.json();
        return (Array.isArray(arr) ? arr : [])
            .map(r => [new Date(r.t).valueOf(), Number(r.v)])
            .filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1]))
            .sort((a, b) => a[0] - b[0]);
    }


    // è®¡ç®—å‡å€¼Â±æ ‡å‡†å·®å¸¦ï¼šè¿”å› {lower: [...], range: [...]}ï¼Œç”¨äº stack å¡«å……
    function buildMeanStdBand(meanData, stdData) {
        // std æŒ‰æ—¶é—´å¯¹é½ï¼ˆä»¥ mean çš„æ—¶é—´æˆ³ä¸ºå‡†ï¼Œç¼ºå¤±åˆ™å¿½ç•¥ï¼‰
        const stdByTs = new Map(stdData.map(([t, v]) => [t, v]));
        const lower = [];
        const range = [];
        for (const [t, m] of meanData) {
            const s = stdByTs.get(t);
            if (!Number.isFinite(s)) continue;
            const lo = m - s;
            const hi = m + s;
            lower.push([t, lo]);
            range.push([t, hi - lo]); // stack: ä¸‹é¢æ˜¯ lowerï¼Œä¸Šé¢å¡«å…… (upper - lower)
        }
        return {lower, range};
    }

    // ç”Ÿæˆâ€œå‡å€¼å®çº¿ + ä¸Šä¸‹ç•Œå¸¦ï¼ˆå¡«å……ï¼‰â€çš„ 2+1 ä¸ªç³»åˆ—
    function bandSeriesForMeanStd(legendBase, color, meanData, stdData) {
        const series = [];
        if (stdData && stdData.length) {
            const {lower, range} = buildMeanStdBand(meanData, stdData);
            series.push({
                id: `band:lower:${legendBase}`,
                name: `${legendBase} ä¸‹ç•Œ`,
                type: 'line',
                showSymbol: false,
                xAxisIndex: 0, yAxisIndex: 0,
                lineStyle: {width: 0}, // éšè—ä¸‹ç•Œçº¿
                stack: `band:${legendBase}`,
                data: lower
            });
            series.push({
                id: `band:range:${legendBase}`,
                name: `${legendBase} åŒºé—´`,
                type: 'line',
                showSymbol: false,
                xAxisIndex: 0, yAxisIndex: 0,
                lineStyle: {width: 0},
                areaStyle: {opacity: 0.18},     // ä½¿ç”¨å‡å€¼è‰²çš„æµ…å¡«å……ï¼ˆé¢œè‰²è·Ÿéšå›¾ä¾‹è‰²ï¼‰
                itemStyle: {color},
                stack: `band:${legendBase}`,
                data: range
            });
        }
        // å‡å€¼å®çº¿ï¼ˆåœ¨ä¸Šå±‚ï¼‰
        series.push({
            id: `feat:mean:${legendBase}`,
            name: `${legendBase} Â· mean`,
            type: 'line',
            showSymbol: false,
            smooth: 0.15,
            xAxisIndex: 0, yAxisIndex: 0,
            emphasis: {focus: 'series'},
            lineStyle: {width: 2, color},
            itemStyle: {color},
            data: meanData
        });
        return series;
    }

    // åœ¨æŸä¸ª part å­å›¾ä¸Šæ¸²æŸ“ feature çº¿ï¼ˆnames ä¾‹å¦‚ ['mean','std']ï¼‰
    // åœ¨ features å›¾é‡ŒæŠŠ std å˜æˆ mean çš„ä¸Šä¸‹ç•Œé˜´å½±å¸¦ï¼›å›¾ä¾‹åªæ˜¾ç¤º mean
    async function drawFeatureLinesForPart(partNumber, scope, names, startUtc, endUtc) {
        const inst = ensureFeatureChartForPart(partNumber);

        // é‡ç½®åæ ‡è½´ï¼ˆä¿æŒä½ åŸæœ‰çš„æ—¥ç²’åº¦åˆ»åº¦ï¼‰
        inst.setOption(baseOptionForFeature(), true);
        ensureDailyTicksOn(inst);

        // æ‹‰å–æ‰€éœ€æŒ‡æ ‡
        const all = await Promise.all(
            (names || []).map(n =>
                fetchFeaturePointsSimple(scope, n, startUtc, endUtc)
                    .then(rows => ({name: String(n).toLowerCase(), rows}))
            )
        );

        // å·¥å…·ï¼šè¡Œ -> [t(ms), v] ä¸”æ’åº
        function toPairs(rows) {
            return (rows || [])
                .map(r => [new Date(r.t).getTime(), Number(r.v)])
                .filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1]))
                .sort((a, b) => a[0] - b[0]);
        }

        const meanData = toPairs(all.find(x => x.name === 'mean')?.rows || []);
        const stdData = toPairs(all.find(x => x.name === 'std')?.rows || []);

        const series = [];
        const legendNames = []; // åªæŠŠ mean æ”¾è¿›å›¾ä¾‹
        const K = 1;            // kÂ·stdï¼Œè‹¥éœ€ 95% ç½®ä¿¡åŒºé—´å¯æ”¹æˆ 1.96

        if (meanData.length && stdData.length) {
            // å¯¹é½åˆ°ç›¸åŒæ—¶é—´æˆ³
            const stdMap = new Map(stdData.map(([t, v]) => [t, v]));
            const lower = [];
            const upperDiff = []; // stack æŠ€å·§ï¼šç”¨ (upper - lower) ä½œä¸ºç¬¬äºŒå±‚å®ç°â€œåŒºé—´å¡«å……â€
            for (const [t, m] of meanData) {
                const s = stdMap.get(t);
                if (!Number.isFinite(s)) continue;
                const lo = m - K * s;
                const hi = m + K * s;
                lower.push([t, lo]);
                upperDiff.push([t, hi - lo]);
            }

            if (lower.length) {
                // baselineï¼ˆä¸å¯è§ï¼Œåªä½œä¸º area çš„åŸºçº¿ï¼‰
                series.push({
                    id: `feat:band:baseline`,
                    name: '__band_base__',
                    type: 'line',
                    showSymbol: false,
                    smooth: 0.15,
                    xAxisIndex: 0, yAxisIndex: 0,
                    lineStyle: {width: 0, opacity: 0},
                    stack: 'Â±Ïƒ',
                    data: lower,
                    silent: true
                });
                // é˜´å½±å¸¦ï¼ˆä¸Šå±‚ï¼‰ï¼šç”¨ areaStyle å¡«å……ï¼Œé¢œè‰²ç”±è°ƒè‰²æ¿è‡ªåŠ¨å–ï¼Œé€æ˜åº¦è¾ƒä½
                series.push({
                    id: `feat:band:area`,
                    name: 'Â±std',
                    type: 'line',
                    showSymbol: false,
                    smooth: 0.15,
                    xAxisIndex: 0, yAxisIndex: 0,
                    lineStyle: {width: 0, opacity: 0},
                    areaStyle: {opacity: 0.18},
                    stack: 'Â±Ïƒ',
                    data: upperDiff,
                    silent: true
                });
            }

            // æœ€åæŠŠ mean ç”»åœ¨æœ€ä¸Šå±‚ï¼ˆçº¿å®½ 2ï¼‰
            series.push({
                id: `feat:mean`,
                name: 'mean',
                type: 'line',
                showSymbol: false,
                smooth: 0.15,
                xAxisIndex: 0, yAxisIndex: 0,
                lineStyle: {width: 2},
                data: meanData
            });
            legendNames.push('mean');
            const others = all.filter(o => o.name !== 'mean' && o.name !== 'std');
            others.forEach((o, idx) => {
                const data = toPairs(o.rows || []);
                if (!data.length) return;
                // è®© WMA ç”¨è™šçº¿ï¼Œå…¶ä»–ç”¨å®çº¿ï¼›é¢œè‰²äº¤ç»™ ECharts è°ƒè‰²æ¿
                const isWma = /^wma/i.test(o.name);
                const pretty = o.name.replace(/^wma(\d+)m$/i, 'WMA($1m)');
                series.push({
                    id: `feat:${o.name}`,
                    name: pretty,
                    type: 'line',
                    showSymbol: false,
                    smooth: 0.15,
                    xAxisIndex: 0, yAxisIndex: 0,
                    lineStyle: {width: 1.5, type: isWma ? 'dashed' : 'solid'},
                    data
                });
                legendNames.push(pretty);
            });


        } else {
            // å¦‚æœ std ç¼ºå¤±ï¼Œä¿æŒåŸæœ‰è¡Œä¸ºï¼šæŠŠå·²æœ‰æŒ‡æ ‡é€æ¡ç”»å‡ºæ¥ï¼ˆå‘åå…¼å®¹ï¼‰
            for (const o of all) {
                const data = toPairs(o.rows || []);
                if (!data.length) continue;
                series.push({
                    id: `feat:${o.name}`,
                    name: o.name,
                    type: 'line',
                    showSymbol: false,
                    smooth: 0.15,
                    xAxisIndex: 0, yAxisIndex: 0,
                    lineStyle: {width: 2},
                    data
                });
                legendNames.push(o.name);
            }
        }

        // åªæŠŠ mean æ”¾å…¥å›¾ä¾‹ï¼ŒåŒºé—´å¸¦ä¸è¿›å›¾ä¾‹ï¼Œé¿å…å¹²æ‰°
        inst.setOption({
            legend: {data: legendNames},
            series
        }, {notMerge: false, lazyUpdate: true});
        adjustGridTopForLegend(inst);
    }

    // === ç®€åŒ–ç‰ˆï¼šå¯¹å•ä¸ª scope / å•ä¸ª part æ‹‰ mean+std å¹¶ç”»åˆ° Feature å­å›¾ ===
    async function updateFeatureForScopePart({partNumber, scope, startIso, endIso, names = FEATURE_NAMES_DEFAULT}) {
        const startUtc = toUtcZ(startIso);
        const endUtc = toUtcZ(endIso);
        // è¿™é‡Œ names = FEATURE_NAMES_DEFAULT = ['mean', 'std']
        await drawFeatureLinesForPart(partNumber, scope, names, startUtc, endUtc);
    }


    async function updateFeatureSnapshot({seriesInputs, title, startIso, endIso}) {
        const PART_BY_IPHONE_ID = (() => {
            const m = new Map();
            IPHONE_ID_BY_PART.forEach((id, pn) => m.set(Number(id), pn));
            return m;
        })();

        function resolvePart(si) {
            const m = String(si.legend || '').match(/^([^Â·]+)\s*Â·/);
            if (m) return m[1].trim();
            const m2 = String(si.scope || '').match(/iphone:(\d+)/);
            if (m2) {
                const pn = PART_BY_IPHONE_ID.get(Number(m2[1]));
                if (pn) return pn;
            }
            return ACTIVE_PART_NUMBER || 'UNKNOWN_PART';
        }

        const grouped = new Map();
        (seriesInputs || []).forEach(si => {
            const part = resolvePart(si);
            if (!grouped.has(part)) grouped.set(part, []);
            grouped.get(part).push(si);
        });

        const startMs = new Date(startIso).getTime(), endMs = new Date(endIso).getTime();

        for (const [part, sis] of grouped.entries()) {
            const inst = ensureFeatureChartForPart(part);
            inst.setOption(baseOptionForFeature(), true);

            // è‹¥åªæœ‰ meanï¼Œåˆ™è‡ªåŠ¨è¡¥ä¸€æ¡ std
            const hasStd = sis.some(x => String(x.name).toLowerCase() === 'std');
            const finalSis = hasStd ? sis : ([
                ...sis,
                ...sis.filter(x => String(x.name).toLowerCase() === 'mean')
                    .map(x => ({...x, name: 'std', legend: (x.legend || '').replace(/mean/i, 'std')}))
            ]);

            const results = await Promise.all(
                finalSis.map((si, i) => (async () => {
                        const data = await fetchFeatureSeries({scope: si.scope, name: si.name, startIso, endIso});
                        return {
                            legend: si.legend || si.name,      // å¦‚ "iPhone 15 Pro 256GB ç™½ Â· mean"
                            metric: si.name,                   // 'mean' / 'std'
                            scope: si.scope,
                            color: LINE_PALETTE[i % LINE_PALETTE.length],
                            data
                        };
                    })
                )
            );

            const groups = new Map(); // legendBase -> {mean:[], std:[], color}
            for (const r of results) {
                // legend å¯èƒ½å½¢å¦‚ "iPhone 15 Pro 256GB ç™½ Â· mean"
                const base = String(r.legend).replace(/\s*Â·\s*(mean|std)$/i, '');
                const g = groups.get(base) || {mean: null, std: null, color: r.color};
                if (/^mean$/i.test(r.metric)) g.mean = r.data;
                else if (/^std$/i.test(r.metric)) g.std = r.data;
                if (!groups.has(base)) groups.set(base, g);
            }

            const finalSeries = [];
            for (const [legendBase, g] of groups.entries()) {
                if (!g.mean || !g.mean.length) continue;
                const color = g.color || LINE_PALETTE[0];
                const merged = bandSeriesForMeanStd(legendBase, color, g.mean, g.std || []);
                finalSeries.push(...merged);
            }

            inst.setOption({
                title: {
                    text: 'FeatureSnapshot',
                    subtext: title.includes(humanNameOfPart(part)) ? title : `${title}ï½œ${humanNameOfPart(part)}`,
                    left: 12, top: 18, textStyle: {fontSize: 14}
                },
                legend: {data: Array.from(groups.keys()).map(b => `${b} Â· mean`)},
                series: finalSeries
            }, false);

            applyWorkHoursOverlayOn(inst, startMs, endMs);
            ensureDailyTicksOn(inst);
            adjustGridTopForLegend(inst);
        }
    }

    /* ===================== 6) äº”ç§åŠ è½½å¤„ç†å™¨ï¼ˆA ä¿ä¸»å›¾ï¼ŒB/C/D/E åˆ†å›¾ï¼‰ ===================== */


    async function runWithLimit(tasks, limit = RAW_CONC_LIMIT) {
        const ret = [];
        let i = 0, running = 0;
        return new Promise(resolve => {
            const next = () => {
                if (i >= tasks.length && running === 0) return resolve(Promise.all(ret));
                while (running < limit && i < tasks.length) {
                    const p = tasks[i++]().finally(() => {
                        running--;
                        next();
                    });
                    running++;
                    ret.push(p);
                }
            };
            next();
        });
    }

    async function ensureScopesReady() {
        if (!SHOP_PROFILES.length || !COHORTS.length) {
            const sc = await loadScopesOnce();
            SHOP_PROFILES = extractProfilesFromScopes(sc);
            COHORTS = extractCohortsFromScopes(sc);
            PROFILE_BY_ID = new Map(SHOP_PROFILES.map(p => [Number(p.id), p]));
            COHORT_BY_ID = new Map(COHORTS.map(c => [Number(c.id), c]));
        }
    }

    /* â€”â€” Aï¼šå•åº— Ã— å• partï¼ˆä¸»å›¾ï¼‰ â€”â€” */
    async function handleLoadS1() {
        await ensureScopesReady();
        $('status') && ($('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦');
        $('err') && ($('err').textContent = '');

        // å°† datalist çš„éšè— id ä¸è¾“å…¥æ¡†åŒæ­¥ï¼ˆè‹¥å­˜åœ¨ï¼‰
        $('sA_shop')?.dispatchEvent(new Event('blur'));
        $('sA_part')?.dispatchEvent(new Event('blur'));

        const part = $('sA_part')?.value?.trim();
        const sidStr = $('sA_shop_id')?.value?.trim();
        const iphoneIdStr = $('sA_iphone_id')?.value?.trim();

        const startIso = toIsoLocal($('start')?.value);
        const endIso = toIsoLocal($('end')?.value);

        if (!sidStr || !part || !startIso || !endIso) {
            $('err') && ($('err').textContent = 'A) å‚æ•°ä¸å®Œæ•´ï¼ˆåº—é“º/part/start/endï¼‰');
            return;
        }

        const sid = Number(sidStr);
        const iphoneIdVal = iphoneIdStr ? Number(iphoneIdStr) : NaN;
        SELECTED_START_MS = new Date(startIso).getTime();
        SELECTED_END_MS = new Date(endIso).getTime();
        ACTIVE_PART_NUMBER = part;
        ACTIVE_IPHONE_ID = Number.isFinite(iphoneIdVal) ? iphoneIdVal : (IPHONE_ID_BY_PART.get(part) ?? null);
        SELECTED_SHOP_IDS = new Set([sid]);

        // æ¸…ç©ºåˆ†å›¾ï¼ˆA åªç”»ä¸»å›¾ï¼‰
        disposeAllPartCharts();
        clear3DCharts();  // æ¸…ç©º3Då›¾è¡¨
        clearBubbleCharts();  // æ¸…ç©ºæ°”æ³¡å›¾

        try {
            const sname = SHOPS_INDEX.get(sid) || `#${sid}`;
            const r = await fetchOneShopSeries(SERIES_API_BASE, startIso, endIso, sid, sname, part);
            const color = getColorForShop({name: sname, id: sid}, 0);
            const data = appendShadowToNowIfNeeded(r.data.slice());
            addOrUpdateSeries(`raw:s:${sid}|p:${part}`, sname, color, data);

            // æ”¶é›†3Dæ•°æ®ç‚¹å’Œæ°”æ³¡å›¾æ•°æ®ç‚¹
            const iphoneInfo = IPHONE_INFO_BY_PART.get(part);
            const iphoneColor = iphoneInfo?.color || 'ä¸æ˜';
            data.forEach(point => {
                if (Array.isArray(point) && point.length >= 2) {
                    collect3DDataPoint(sid, sname, color, point[0], point[1], part, iphoneColor);
                    collectBubbleDataPoint(sid, sname, color, point[0], point[1], part, iphoneColor);
                }
            });
            render3DChartsFromCollectedData();  // æ¸²æŸ“3Då›¾è¡¨
            renderBubbleChartsFromCollectedData();  // æ¸²æŸ“æ°”æ³¡å›¾

            $('status') && ($('status').textContent = `A) å®Œäº†ï¼š${sname} Ã— ${part}`);


            const iphoneId = Number($('sA_iphone_id').value) || (IPHONE_ID_BY_PART.get(part) ?? null);
            if (Number.isFinite(iphoneId)) {
                const scope = buildFeatureScope({shopId: sid, iphoneId});
                await updateFeatureForScopePart({
                    partNumber: part,
                    scope,
                    startIso,
                    endIso
                });
            }
            // ä¸»å›¾å è¥ä¸šæ—¶æ®µ
            if (chart) {
                chart.setOption({
                    series: [{
                        id: '__workhours__',
                        type: 'line',
                        data: [],
                        markArea: buildBusinessHoursMarkArea10to19(SELECTED_START_MS, SELECTED_END_MS),
                        silent: true, z: -10
                    }]
                }, {notMerge: false, lazyUpdate: true});
                ensureDailyTicksOn(chart);
                applyWorkHoursOverlayAll(SELECTED_START_MS, SELECTED_END_MS);  // â˜…
            }

        } catch (e) {
            $('err') && ($('err').textContent = `A) èª­ã¿è¾¼ã¿å¤±æ•—ï¼š${e.message}`);
        }
    }

    /* â€”â€” Bï¼šå…¨éƒ¨åº— Ã— Cohort å†…æ‰€æœ‰ partï¼ˆåˆ†å›¾ï¼šæ¯ä¸ª part ä¸€å¼ ï¼‰ â€”â€” */
    async function handleLoadS2() {
        await ensureScopesReady();
        $('status') && ($('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦');
        $('err') && ($('err').textContent = '');
        $('sB_cohort')?.dispatchEvent(new Event('blur'));

        const cohIdStr = $('sB_cohort_id')?.value?.trim();
        const startIso = toIsoLocal($('start')?.value);
        const endIso = toIsoLocal($('end')?.value);
        if (!cohIdStr || !startIso || !endIso) {
            $('err') && ($('err').textContent = 'B) å‚æ•°ä¸å®Œæ•´ï¼ˆcohort/start/endï¼‰');
            return;
        }
        const cohId = Number(cohIdStr);
        const cohort = COHORTS.find(c => Number(c.id) === cohId);
        if (!cohort || !(cohort.members || []).length) {
            $('err') && ($('err').textContent = 'B) è¯¥ Cohort æ— æˆå‘˜æˆ–æœªè¯†åˆ«');
            return;
        }

        SELECTED_START_MS = new Date(startIso).getTime();
        SELECTED_END_MS = new Date(endIso).getTime();
        disposeAllPartCharts();  // æ¸…ç©ºæ—§åˆ†å›¾
        clear3DCharts();  // æ¸…ç©º3Då›¾è¡¨
        clearBubbleCharts();  // æ¸…ç©ºæ°”æ³¡å›¾

        const allShops = [...SHOPS_INDEX.keys()];
        const pairs = [];
        for (const sid of allShops) for (const m of (cohort.members || [])) pairs.push([Number(sid), String(m.part_number)]);
        let clipped = false;
        if (pairs.length > RAW_MAX_SERIES) {
            pairs.length = RAW_MAX_SERIES;
            clipped = true;
        }
        const aggByShop = new Map();

        const tasks = pairs.map(([sid, part]) => async () => {
            const sname = SHOPS_INDEX.get(sid) || `#${sid}`;
            const r = await fetchOneShopSeries(SERIES_API_BASE, startIso, endIso, sid, sname, part);
            const color = getColorForShop({name: sname, id: sid}, sid);
            const data = appendShadowToNowIfNeeded(r.data.slice());
            addOrUpdateSeriesForPart(part, `s:${sid}`, sname, color, data);
            if (!aggByShop.has(sid)) aggByShop.set(sid, []);
            aggByShop.get(sid).push(data);

            // æ”¶é›†3Dæ•°æ®ç‚¹å’Œæ°”æ³¡å›¾æ•°æ®ç‚¹
            const iphoneInfo = IPHONE_INFO_BY_PART.get(part);
            const iphoneColor = iphoneInfo?.color || 'ä¸æ˜';
            data.forEach(point => {
                if (Array.isArray(point) && point.length >= 2) {
                    collect3DDataPoint(sid, sname, color, point[0], point[1], part, iphoneColor);
                    collectBubbleDataPoint(sid, sname, color, point[0], point[1], part, iphoneColor);
                }
            });
        });

        try {
            await runWithLimit(tasks, RAW_CONC_LIMIT);
            renderAggregateOnMain(aggByShop, SELECTED_START_MS, SELECTED_END_MS);
            render3DChartsFromCollectedData();  // æ¸²æŸ“3Då›¾è¡¨
            renderBubbleChartsFromCollectedData();  // æ¸²æŸ“æ°”æ³¡å›¾
            ensureDailyTicksAll();
            applyWorkHoursOverlayAll(SELECTED_START_MS, SELECTED_END_MS);
            $('status') && ($('status').textContent = `B) å®Œäº†ï¼š${cohort.title || cohort.label}${clipped ? 'ï¼ˆå·²æˆªæ–­æ˜¾ç¤ºï¼‰' : ''}`);

            // Featureï¼šå…¨åº—èšåˆ profileï¼ˆå‡è®¾ slug=full_storeï¼‰
            const FULL_STORE_SLUG = (SHOP_PROFILES.find(p => p.slug === 'full_store')?.slug) || 'full_store';

            for (const m of (cohort.members || [])) {
                const iid = Number(m.iphone_id);
                if (!Number.isFinite(iid)) continue;
                const scope = buildFeatureScope({profileSlug: FULL_STORE_SLUG, iphoneId: iid});
                await updateFeatureForScopePart({
                    partNumber: m.part_number,
                    scope,
                    startIso,
                    endIso
                });
            }
        } catch (e) {
            $('err') && ($('err').textContent = `B) èª­ã¿è¾¼ã¿å¤±æ•—ï¼š${e.message}`);
        }
    }

    /* â€”â€” Cï¼šProfile å†…æ‰€æœ‰åº— Ã— å• partï¼ˆåˆ†å›¾ï¼šè¯¥ part ä¸€å¼ ï¼‰ â€”â€” */
    async function handleLoadS3() {
        await ensureScopesReady();
        $('status') && ($('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦');
        $('err') && ($('err').textContent = '');
        $('sC_profile')?.dispatchEvent(new Event('blur'));
        $('sC_part')?.dispatchEvent(new Event('blur'));

        const profIdStr = $('sC_profile_id')?.value?.trim();
        const part = $('sC_part')?.value?.trim();
        const startIso = toIsoLocal($('start')?.value);
        const endIso = toIsoLocal($('end')?.value);
        if (!profIdStr || !part || !startIso || !endIso) {
            $('err') && ($('err').textContent = 'C) å‚æ•°ä¸å®Œæ•´ï¼ˆprofile/part/start/endï¼‰');
            return;
        }
        const profile = SHOP_PROFILES.find(p => Number(p.id) === Number(profIdStr));
        if (!profile || !(profile.items || []).length) {
            $('err') && ($('err').textContent = 'C) æœªè¯†åˆ«çš„ åº—èˆ—çµ„åˆã› æˆ–æ— æˆå‘˜');
            return;
        }

        SELECTED_START_MS = new Date(startIso).getTime();
        SELECTED_END_MS = new Date(endIso).getTime();
        disposeAllPartCharts();
        clear3DCharts();  // æ¸…ç©º3Då›¾è¡¨
        clearBubbleCharts();  // æ¸…ç©ºæ°”æ³¡å›¾

        const shopIds = (profile.items || []).map(x => Number(x.shop_id));
        const pairs = shopIds.map(sid => [sid, part]);
        let clipped = false;
        if (pairs.length > RAW_MAX_SERIES) {
            pairs.length = RAW_MAX_SERIES;
            clipped = true;
        }
        const aggByShop = new Map();

        const tasks = pairs.map(([sid, p]) => async () => {
            const sname = SHOPS_INDEX.get(sid) || `#${sid}`;
            const r = await fetchOneShopSeries(SERIES_API_BASE, startIso, endIso, sid, sname, p);
            const color = getColorForShop({name: sname, id: sid}, sid);
            const data = appendShadowToNowIfNeeded(r.data.slice());
            addOrUpdateSeriesForPart(p, `s:${sid}`, sname, color, data);
            if (!aggByShop.has(sid)) aggByShop.set(sid, []);
            aggByShop.get(sid).push(data);

            // æ”¶é›†3Dæ•°æ®ç‚¹å’Œæ°”æ³¡å›¾æ•°æ®ç‚¹
            const iphoneInfo = IPHONE_INFO_BY_PART.get(p);
            const iphoneColor = iphoneInfo?.color || 'ä¸æ˜';
            data.forEach(point => {
                if (Array.isArray(point) && point.length >= 2) {
                    collect3DDataPoint(sid, sname, color, point[0], point[1], p, iphoneColor);
                    collectBubbleDataPoint(sid, sname, color, point[0], point[1], p, iphoneColor);
                }
            });
        });

        try {
            await runWithLimit(tasks, RAW_CONC_LIMIT);
            renderAggregateOnMain(aggByShop, SELECTED_START_MS, SELECTED_END_MS);
            render3DChartsFromCollectedData();  // æ¸²æŸ“3Då›¾è¡¨
            renderBubbleChartsFromCollectedData();  // æ¸²æŸ“æ°”æ³¡å›¾
            ensureDailyTicksAll();
            applyWorkHoursOverlayAll(SELECTED_START_MS, SELECTED_END_MS);
            $('status') && ($('status').textContent = `C) å®Œäº†ï¼š${profile.title || profile.label} Ã— ${part}${clipped ? 'ï¼ˆå·²æˆªæ–­æ˜¾ç¤ºï¼‰' : ''}`);

            const iphoneIdC = Number($('sC_iphone_id').value) || (IPHONE_ID_BY_PART.get(part) ?? null);
            const profileSlugC = (profile && profile.slug) || null;
            if (Number.isFinite(iphoneIdC) && profileSlugC) {
                const scope = buildFeatureScope({profileSlug: profileSlugC, iphoneId: iphoneIdC});
                await updateFeatureForScopePart({
                    partNumber: part,
                    scope,
                    startIso,
                    endIso
                });
            }
        } catch (e) {
            $('err') && ($('err').textContent = `C) èª­ã¿è¾¼ã¿å¤±æ•—ï¼š${e.message}`);
        }
    }

    /* â€”â€” Dï¼šå•åº— Ã— Cohort å†…æ‰€æœ‰ partï¼ˆåˆ†å›¾ï¼šæ¯ä¸ª part ä¸€å¼ ï¼‰ â€”â€” */
    async function handleLoadS4() {
        await ensureScopesReady();
        $('status') && ($('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦');
        $('err') && ($('err').textContent = '');
        $('sD_shop')?.dispatchEvent(new Event('blur'));
        $('sD_cohort')?.dispatchEvent(new Event('blur'));

        const sidStr = $('sD_shop_id')?.value?.trim();
        const cohIdStr = $('sD_cohort_id')?.value?.trim();
        const startIso = toIsoLocal($('start')?.value);
        const endIso = toIsoLocal($('end')?.value);
        if (!sidStr || !cohIdStr || !startIso || !endIso) {
            $('err') && ($('err').textContent = 'D) å‚æ•°ä¸å®Œæ•´ï¼ˆåº—é“º/cohort/start/endï¼‰');
            return;
        }
        const sid = Number(sidStr);
        const cohort = COHORTS.find(c => Number(c.id) === Number(cohIdStr));
        if (!cohort || !(cohort.members || []).length) {
            $('err') && ($('err').textContent = 'D) æœªè¯†åˆ«çš„ Cohort æˆ–æ— æˆå‘˜');
            return;
        }
        const sname = SHOPS_INDEX.get(sid) || `#${sid}`;
        SELECTED_START_MS = new Date(startIso).getTime();
        SELECTED_END_MS = new Date(endIso).getTime();
        disposeAllPartCharts();
        clear3DCharts();  // æ¸…ç©º3Då›¾è¡¨
        clearBubbleCharts();  // æ¸…ç©ºæ°”æ³¡å›¾

        const pairs = (cohort.members || []).map(m => [sid, String(m.part_number)]);
        let clipped = false;
        if (pairs.length > RAW_MAX_SERIES) {
            pairs.length = RAW_MAX_SERIES;
            clipped = true;
        }

        const tasks = pairs.map(([s, p]) => async () => {
            const r = await fetchOneShopSeries(SERIES_API_BASE, startIso, endIso, s, sname, p);
            const color = getColorForShop({name: sname, id: s}, s);
            const data = appendShadowToNowIfNeeded(r.data.slice());
            addOrUpdateSeriesForPart(p, `s:${s}`, sname, color, data);

            // æ”¶é›†3Dæ•°æ®ç‚¹å’Œæ°”æ³¡å›¾æ•°æ®ç‚¹
            const iphoneInfo = IPHONE_INFO_BY_PART.get(p);
            const iphoneColor = iphoneInfo?.color || 'ä¸æ˜';
            data.forEach(point => {
                if (Array.isArray(point) && point.length >= 2) {
                    collect3DDataPoint(s, sname, color, point[0], point[1], p, iphoneColor);
                    collectBubbleDataPoint(s, sname, color, point[0], point[1], p, iphoneColor);
                }
            });
        });

        try {
            await runWithLimit(tasks, RAW_CONC_LIMIT);
            render3DChartsFromCollectedData();  // æ¸²æŸ“3Då›¾è¡¨
            renderBubbleChartsFromCollectedData();  // æ¸²æŸ“æ°”æ³¡å›¾
            ensureDailyTicksAll();
            applyWorkHoursOverlayAll(SELECTED_START_MS, SELECTED_END_MS);
            $('status') && ($('status').textContent = `D) å®Œäº†ï¼š${sname} Ã— ${cohort.title || cohort.label}${clipped ? 'ï¼ˆå·²æˆªæ–­æ˜¾ç¤ºï¼‰' : ''}`);

            for (const m of (cohort.members || [])) {
                const iid = Number(m.iphone_id);
                if (!Number.isFinite(iid)) continue;
                const scope = buildFeatureScope({shopId: sid, iphoneId: iid});
                await updateFeatureForScopePart({
                    partNumber: m.part_number,
                    scope,
                    startIso,
                    endIso
                });
            }
        } catch (e) {
            $('err') && ($('err').textContent = `D) èª­ã¿è¾¼ã¿å¤±æ•—ï¼š${e.message}`);
        }
    }

    /* â€”â€” Eï¼šProfile å†…æ‰€æœ‰åº— Ã— Cohort å†…æ‰€æœ‰ partï¼ˆåˆ†å›¾ï¼šæ¯ä¸ª part ä¸€å¼ ï¼‰ â€”â€” */
    async function handleLoadS5() {
        await ensureScopesReady();
        $('status') && ($('status').textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦');
        $('err') && ($('err').textContent = '');
        $('sE_profile')?.dispatchEvent(new Event('blur'));
        $('sE_cohort')?.dispatchEvent(new Event('blur'));

        const profIdStr = $('sE_profile_id')?.value?.trim();
        const cohIdStr = $('sE_cohort_id')?.value?.trim();
        const startIso = toIsoLocal($('start')?.value);
        const endIso = toIsoLocal($('end')?.value);
        if (!profIdStr || !cohIdStr || !startIso || !endIso) {
            $('err') && ($('err').textContent = 'E) å‚æ•°ä¸å®Œæ•´ï¼ˆprofile/cohort/start/endï¼‰');
            return;
        }
        const profile = SHOP_PROFILES.find(p => Number(p.id) === Number(profIdStr));
        const cohort = COHORTS.find(c => Number(c.id) === Number(cohIdStr));
        if (!profile || !(profile.items || []).length) {
            $('err') && ($('err').textContent = 'E) æœªè¯†åˆ«çš„ åº—èˆ—çµ„åˆã› æˆ–æ— åº—é“ºæˆå‘˜');
            return;
        }
        if (!cohort || !(cohort.members || []).length) {
            $('err') && ($('err').textContent = 'E) æœªè¯†åˆ«çš„ Cohort æˆ–æ—  iPhone æˆå‘˜');
            return;
        }

        SELECTED_START_MS = new Date(startIso).getTime();
        SELECTED_END_MS = new Date(endIso).getTime();
        disposeAllPartCharts();
        clear3DCharts();  // æ¸…ç©º3Då›¾è¡¨
        clearBubbleCharts();  // æ¸…ç©ºæ°”æ³¡å›¾

        const shopIds = (profile.items || []).map(x => Number(x.shop_id));
        const members = cohort.members || [];
        const pairs = [];
        for (const s of shopIds) for (const m of members) pairs.push([s, String(m.part_number)]);
        let clipped = false;
        if (pairs.length > RAW_MAX_SERIES) {
            pairs.length = RAW_MAX_SERIES;
            clipped = true;
        }
        const aggByShop = new Map();


        const tasks = pairs.map(([s, p]) => async () => {
            const sname = SHOPS_INDEX.get(s) || `#${s}`; // â† ä¿®æ­£ï¼šå±€éƒ¨å®šä¹‰ sname
            const r = await fetchOneShopSeries(SERIES_API_BASE, startIso, endIso, s, sname, p);
            const color = getColorForShop({name: sname, id: s}, s);
            const data = appendShadowToNowIfNeeded(r.data.slice());
            addOrUpdateSeriesForPart(p, `s:${s}`, sname, color, data);
            if (!aggByShop.has(s)) aggByShop.set(s, []);
            aggByShop.get(s).push(data);

            // æ”¶é›†3Dæ•°æ®ç‚¹å’Œæ°”æ³¡å›¾æ•°æ®ç‚¹
            const iphoneInfo = IPHONE_INFO_BY_PART.get(p);
            const iphoneColor = iphoneInfo?.color || 'ä¸æ˜';
            data.forEach(point => {
                if (Array.isArray(point) && point.length >= 2) {
                    collect3DDataPoint(s, sname, color, point[0], point[1], p, iphoneColor);
                    collectBubbleDataPoint(s, sname, color, point[0], point[1], p, iphoneColor);
                }
            });
        });

        try {
            await runWithLimit(tasks, RAW_CONC_LIMIT);
            renderAggregateOnMain(aggByShop, SELECTED_START_MS, SELECTED_END_MS);
            render3DChartsFromCollectedData();  // æ¸²æŸ“3Då›¾è¡¨
            renderBubbleChartsFromCollectedData();  // æ¸²æŸ“æ°”æ³¡å›¾
            ensureDailyTicksAll();
            applyWorkHoursOverlayAll(SELECTED_START_MS, SELECTED_END_MS);
            $('status') && ($('status').textContent = `E) å®Œäº†ï¼š${profile.title || profile.label} Ã— ${cohort.title || cohort.label}${clipped ? 'ï¼ˆå·²æˆªæ–­æ˜¾ç¤ºï¼‰' : ''}`);

            const profileSlugE = (profile && profile.slug) || null;
            if (profileSlugE) {
                for (const m of (members || [])) {
                    const iid = Number(m.iphone_id);
                    if (!Number.isFinite(iid)) continue;
                    const scope = buildFeatureScope({profileSlug: profileSlugE, iphoneId: iid});
                    await updateFeatureForScopePart({
                        partNumber: m.part_number,
                        scope,
                        startIso,
                        endIso
                    });
                }
            }
        } catch (e) {
            $('err') && ($('err').textContent = `E) èª­ã¿è¾¼ã¿å¤±æ•—ï¼š${e.message}`);
        }
    }

    /* ===================== 7) äº‹ä»¶ç»‘å®šä¸é»˜è®¤åˆå§‹åŒ– ===================== */

    document.getElementById('reset')?.addEventListener('click', () => {
        const inst = getMainChart();
        if (inst) inst.setOption(baseOption, true);
        disposeAllPartCharts(); // åŒæ—¶æ¸…ç©ºæ‰€æœ‰ PN å­å›¾
        clear3DCharts(); // æ¸…ç©ºæ‰€æœ‰ 3D å›¾è¡¨
        clearBubbleCharts(); // æ¸…ç©ºæ‰€æœ‰æ°”æ³¡å›¾
    });

    [
        ['btn_load_A', handleLoadS1], ['btn-load-s1', handleLoadS1],
        ['btn_load_B', handleLoadS2], ['btn-load-s2', handleLoadS2],
        ['btn_load_C', handleLoadS3], ['btn-load-s3', handleLoadS3],
        ['btn_load_D', handleLoadS4], ['btn-load-s4', handleLoadS4],
        ['btn_load_E', handleLoadS5], ['btn-load-s5', handleLoadS5],
    ].forEach(([id, fn]) => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('click', fn);
    });

    document.getElementById('select-all')?.addEventListener('click', () => {
        document.querySelectorAll('#shops input[type=checkbox][data-shop-id], #shops input[type=checkbox][value]').forEach(cb => cb.checked = true);
    });
    document.getElementById('clear-all')?.addEventListener('click', () => {
        document.querySelectorAll('#shops input[type=checkbox][data-shop-id], #shops input[type=checkbox][value]').forEach(cb => cb.checked = false);
    });

    /* è‡ªåŠ¨æŠŠ end è¾“å…¥åŒæ­¥åˆ°â€œå½“å‰æœ€è¿‘æ•´åˆ†é’Ÿï¼ˆJSTï¼‰â€ï¼Œè‹¥é¡µé¢å­˜åœ¨è¿™äº›è¾“å…¥æ¡† */






    function syncAllEndToNow() {
    const v = nearestPastMinuteInputValueJST();
    ['end', 's2-end', 's3-end', 's4-end', 's5-end'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = v;
    });
}


    function startAutoEndSync() {
        syncAllEndToNow();
        if (END_AUTO_TIMER) clearInterval(END_AUTO_TIMER);
        let lastMinuteMs = floorToMinute(new Date()).getTime();
        END_AUTO_TIMER = setInterval(() => {
            const nowMinuteMs = floorToMinute(new Date()).getTime();
            if (nowMinuteMs !== lastMinuteMs) {
                lastMinuteMs = nowMinuteMs;
                syncAllEndToNow();
            }
        }, 5000);
    }

    /* é¡µé¢åˆå§‹åŒ– */
    (function initDefaults() {
        // ä½ å¯ä»¥æ”¹æˆä½ å¸Œæœ›çš„é»˜è®¤æ—¶é—´èŒƒå›´
        $('start') && ($('start').value = "2025-10-01T10:00");
        $('end') && ($('end').value = "2025-10-20T10:00");

        loadShops();     // æ¸²æŸ“é—¨åº—å¤é€‰æ¡† & å»ºç«‹ SHOPS_INDEX
        loadIphones();   // é¡¶éƒ¨æ—§ iPhone ä¸‹æ‹‰ï¼ˆè‹¥å­˜åœ¨ï¼‰
        startAutoEndSync();
        (async () => {
            try {
                await mountAllScopeSelectors();
            } catch (e) {
                console.warn('[mount scopes selectors] failed', e);
            }
        })();

window.addEventListener('resize', () => {
  ChartGrids.price.forEach(m => { m.chart.resize(); adjustGridTopForLegend(m.chart); });
  ChartGrids.feature.forEach(m => { m.chart.resize(); adjustGridTopForLegend(m.chart); });
});
    })();
</script>

</body>
</html>
